<!-- Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved. Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information. -->
<!DOCTYPE HTML>
<HTML>
<HEAD>
<TITLE>
Documentation and design notes for transitionAnimation.js
</TITLE>
<STYLE>

body
{
    font-family: Calibri, sans-serif;
    font-size: 11pt;
}

h1, h2, h3, h4, h5, h6
{
    font-family: Cambria, serif;
}

h1
{
    font-size: 26pt;
    font-weight: normal;
    color: #17365D;
    padding-bottom: 4pt;
}

h2
{
    border-top: solid #4F81BD 1pt;
    border-left: solid #4F81BD 1pt;
    padding-left: 1ex;
    font-size: 14pt;
    color: #365F91;
}

h3
{
    border-top: solid #4F81BD 1pt;
    font-size: 13pt;
    color: #4F81BD;
}

h4
{
    font-size: 12pt;
    color: #4F81BD;
}

table.grid
{
    border-collapse: collapse;
    margin-bottom: 1em;
}

table.grid .header
{
    background: lightgray;
    font-weight: bold;
}

table.grid td
{
    padding: 4pt;
    border: solid 1px black;
    vertical-align: baseline;
}

.bug
{
    color: red;
}

.fix
{
    background-color: yellow;
}

var
{
    font-family: Consolas, Lucida Console, monospace;
    font-style: normal;
}

code
{
    background: #E8E8E8;
}

blockquote
{
    border: solid 1px black;
    padding-left: 1ex;
    padding-right: 1ex;
    background: #F0F0F0;
}

blockquote var
{
    text-decoration: underline;
    font-style: normal;
    quotes: "&lsquo;" "&rsquo;";
}

.term, .ref
{
    font-style: italic;
}
</STYLE>
</HEAD>

<BODY>
<H1>
Documentation and design notes for transitionAnimation.js
</H1>

<P>
The documentation is in a separate file because we ship
transitionAnimation.js as part of the SDK, so any comments
there are visible to the public.
</P>

<H2>
Transitions vs Animations
</H2>

<P>
Animations do not affect the persistent properties of an object.
When the animation completes, the object's properties return to their
original values.
Some animations base their initial properties on the object's
current properties.
For example, <VAR>enterPage</VAR> animates an element's position
by first displacing it by an offset, and then gradually moving
it to its normal position.
To avoid discontinuity, you should set the object's final properties
to match the final properties of the animation.
</P>

<P>
Transitions change an object's properties from an old value to a new value.
For example, a <VAR>reposition</VAR>
transition visually moves an object from one
position to another.
</P>

<P>
Animations temporarily alter an object's current properties,
and eventually return them to their original values.
For example, an <VAR>enterPage</VAR> animation
takes an element on the screen, temporarily offsets its position,
then gradually animates the element back to its original position.
</P>

<P>
The distinction between animations and transition is that
animations could in theory all be removed from
the application without any change to the logical behavior of the
program.
(The object still appears; it just doesn't look as pretty.)
On the other hand, transitions represent state changes and would
have to be replaced with some other way of changing the visual state.
(The object needs to move from one place to another regardless.)
</P>

<P>
A large drawback with animations are that they require keyframes defined
in css. For animations which have static keyframes we shipped them hard
coded in css. However other ones we create by creating a style tag. In
Windows Blue the performance hit of creating a style tag is much larger
because it is impacted by the number of elements and in Blue the apps 
are more complex and also the ListView control does not virtualize the
win-container elements. We added an options argument to the showEdgeUI
and hideEdgeUI animations so that we can use transitions instead of
animations due to this performance impact. 
</P>

<H2>
Characteristics common to both transitions and animations
</H2>

<P>
From a programmatic standpoint, transitions and animations
are very similar.
For the purpose of this document, we will use the word
<SPAN CLASS=term>action</SPAN> to mean
"transition or animation".
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Characteristic</TD>
    <TD>Transition</TD>
    <TD>Animation</TD>
</TR>
<TR>
    <TD>Lifetime</TD>
    <TD><VAR>-ms-transition-property</VAR></TD>
    <TD><VAR>-ms-animation-name</VAR></TD>
</TR>
<TR>
    <TD>Target property</TD>
    <TD><VAR>-ms-transition-property</VAR></TD>
    <TD><VAR>@keyframe</VAR></TD>
</TR>
<TR>
    <TD>Target values</TD>
    <TD>implied</TD>
    <TD><VAR>@keyframe</VAR></TD>
</TR>
<TR>
    <TD>Initial delay</TD>
    <TD><VAR>-ms-transition-delay</VAR></TD>
    <TD><VAR>-ms-animation-delay</VAR></TD>
</TR>
<TR>
    <TD>Duration</TD>
    <TD><VAR>-ms-transition-duration</VAR></TD>
    <TD><VAR>-ms-animation-duration</VAR></TD>
</TR>
<TR>
    <TD>Curve</TD>
    <TD><VAR>-ms-transition-timing-function</VAR></TD>
    <TD><VAR>-ms-animation-timing-function</VAR></TD>
</TR>
<TR>
    <TD>Direction</TD>
    <TD>always animates forward</TD>
    <TD><VAR>-ms-animation-direction</VAR></TD>
</TR>
<TR>
    <TD>Iteration</TD>
    <TD>Executes only once</TD>
    <TD><VAR>-ms-animation-iteration-count</VAR></TD>
</TR>
<TR>
    <TD>Persistence</TD>
    <TD>always persistent</TD>
    <TD><VAR>-ms-animation-fill-mode</VAR> (sort-of)</TD>
</TR>
<TR>
    <TD>Completion event</TD>
    <TD><VAR>transitionend</VAR></TD>
    <TD><VAR>animationend</VAR></TD>
</TR>
</TABLE>

<P>
All of the properties are comma-separated lists,
corresponding to respective actions.
For example, to apply three actions to an element,
set each of the properties to three values, separated by commas.
Rules exist if one list is shorter than another;
we will not take advantage of those rules,
although we need to guard against the possibility that
the host application may have.
</P>

<P>
(Note that the items in the list are reported by
Internet Explorer as separated by a comma
<EM>and a space</EM>.
This is important to bear in mind
when trying to parse the list back out.)
</P>

<P>
For both transitions and animations,
the properties other than the lifetime property
are <EM>captured</EM> at the moment the action becomes active.
After the action becomes active,
changes to properties other than the lifetime property
are ignored.
<EM>This capture behavior is essential to our design.</EM>
</P>

<P>
The W3C specifies that script-applied actions become active
when the style is resolved.
(Earlier versions of the specification were unclear.)
See <SPAN CLASS=ref>Resolving styles</SPAN> for further
discussion of style resolution.
</P>

<P>
Our overall algorithm for applying actions is as follows.
Detailed discussion of each step follows the outline.
</P>

<UL>
<LI>Remember the pre-existing
    values of the action properties set by the application.
<LI>Set the shorthand action property to a comma-separated list
    of values for that action.
    If there are existing actions,
    the new actions are <EM>appended</EM>
    to the existing lifetime property.
<LI>Return control to the event loop, at which point styles
    will be resolved and the action will trigger.
<LI>As each action completes, remove it from the comma-separated list
    in the lifetime property and clean up the action.
<LI>When the last action completes, restore the original action properties.
<LI>If the completion event has not fired by the time it was
    expected, a watchdog timeout ensures that we do not leave
    the Promise in a permanently-pending state.
</UL>

<P>
It is important to append the new values to the existing properties,
because the W3C says that in case of conflict,
the last one wins.
We set the new values via the shorthand property, because that
solves multiple problems:
</P>
<UL>
<LI>We avoid the need to count commas in the non-lifetime
    action properties.
    (If the individual action properties don't have
    the same number of commas as the action-lifetime property,
    then updating the existing values becomes trickier.)
<LI>We can set multiple properties with a single DOM call.
</UL>
<P>
Note that you <EM>cannot read the action shorthand property</EM>:
In the case where the non-lifetime action properties have the
wrong number of commas,
the shorthand property reads back as an empty string.
(This behavior is required by the CSS specification.)
Instead, we read the action-lifetime property and use just the
names without any of the additional properties.
This works because of the capture behavior described above:
The parameters of the existing actions were already captured,
so the values we provide here are irrelevant.
</P>

<P>
For example, consider the following properties.
Observe that although there are two elements in the lifetime
property,
there are
three in the duration (too many),
only one in the timing-function (too few),
and two in the delay property (just right).
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Property</TD>
    <TD>Value</TD>
</TR>
<TR>
    <TD>lifetime</TD>
    <TD><TT>"a, b"</TT></TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD><TT>"0ms, 300ms, 500ms"</TT></TD>
</TR>
<TR>
    <TD>timing-function</TD>
    <TD><TT>"ease-in"</TT></TD>
<TR>
    <TD>delay</TD>
    <TD><TT>"0ms, 0ms"</TT></TD>
</TR>
</TABLE>

<P>
The CSS specification describes what happens when there are missing
or extra parameters.
The details do not affect us.
</P>

<P>
Suppose we want to start a <TT>"c"</TT> action with
100ms duration, linear timing, and no delay;
and we also want to start a <TT>"d"</TT> action with
100ms duration, linear timing, and 100ms delay.
We first read the lifetime property, then append the
shorthand description of the new action:
</P>

<PRE>
style.lifetime = "a, b, c 100ms linear 0ms, d 100ms linear 100ms"
</PRE>

<P>
The browser parses this and sets multiple properties based on the
shorthand:
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Property</TD>
    <TD>Value</TD>
</TR>
<TR>
    <TD>lifetime</TD>
    <TD><TT>"a, b, c, d"</TT></TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD><TT>"0ms, 0ms, 100ms, 100ms"</TT></TD>
</TR>
<TR>
    <TD>timing-function</TD>
    <TD><TT>"ease, ease, linear, linear"</TT></TD>
</TR>
<TR>
    <TD>delay</TD>
    <TD><TT>"0ms, 0ms, 0ms, 100ms"</TT></TD>
</TR>
</TABLE>

<P>
Providing a name with no auxiliary properties is legal shorthand;
it means that all other properties receive default values.
(Which are ignored, since the action is proceeding with the
captured values.)
</P>

<P>
The first animation to complete is <TT>"c"</TT>, and we clean it up
by deleting its name from the lifetime property.
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Property</TD>
    <TD>Value</TD>
</TR>
<TR>
    <TD>lifetime</TD>
    <TD><TT CLASS=fix>"a, b, d"</TT></TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD><TT>"0ms, 0ms, 100ms, 100ms"</TT></TD>
</TR>
<TR>
    <TD>timing-function</TD>
    <TD><TT>"ease, ease, linear, linear"</TT></TD>
</TR>
<TR>
    <TD>delay</TD>
    <TD><TT>"0ms, 0ms, 0ms, 100ms"</TT></TD>
</TR>
</TABLE>

<P>
Note that the other properties remain unchanged, but that's okay,
because their values were captured when the animation started.
</P>

<P>
When the <TT>"d"</TT> animation completes,
we realize that this is the last PVL animation,
so we restore all the properties to their original values.
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Property</TD>
    <TD>Value</TD>
</TR>
<TR>
    <TD>lifetime</TD>
    <TD><TT>"a, b"</TT></TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD><TT>"0ms, 300ms, 500ms"</TT></TD>
</TR>
<TR>
    <TD>timing-function</TD>
    <TD><TT>"ease-in"</TT></TD>
<TR>
    <TD>delay</TD>
    <TD><TT>"0ms, 0ms"</TT></TD>
</TR>
</TABLE>

<P>
Ignoring the non-lifetime properties during the action
is done as a performance optimization.
Their values have no effect (since the original values were
captured when the action started),
so the work of restoring them is delayed until the
animation completes so that the initial animation can get off
the ground faster.
It does however create the new rule that
<EM>the application may not alter animation or transition
properties while a WinJS animation is in progress</EM>.
</P>

<P>
When removing transitions, we remove the <EM>last matching item</EM>,
so that we do not accidentally damage any values set by the
application,
because we always append our values.
</P>

<P>
For all actions, we listen on the completion event to know
when that action has completed,
and also create a watchdog timer to fire shortly after the
expected completion of the action
to handle the case where the action is abandoned without
firing a completion.
See <SPAN CLASS=ref>Watchdog timeouts</SPAN> for further discussion.
</P>

<P>
All actions register their presence in the
<VAR>activeActions</VAR> array,
which is an array indexed by the combination of the
element's <VAR>uniqueID</VAR> and the
the name of the property being animated.
(Separated by a <CODE>|</CODE>, because that character
is illegal in property names,
so it can safely be used as a separator.)
</P>

<P>
An action registers with a callback function to call
to stop the action.
This is called when a conflicting action is scheduled,
so that the previous action can clean up and get out
of the way before
the new action starts modifying element properties.
(Two actions are said to conflict if they attempt to
animate the same property on the same element.)
See <SPAN CLASS=ref>Finishing due to interruption</SPAN>
for further discussion.
</P>

<P>
If an array of actions or an array of elements is passed,
then each combination of action+element
gets its own listener and watchdog.
All the corresponding Promises are joined together
to become the final Promise of the combined action.
Using the <VAR>Promise.join</VAR> method allows us
to simplify our logic
by allowing us to focus on the one action + one element
scenario.
</P>

<H2>
Forcing layout
</H2>

<P>
In Internet Explorer, <SPAN CLASS=term>layout</SPAN>
is the act of applying the
effects of all changes to the DOM that have taken place.
</P>

<P>
When you change the DOM, such as inserting or deleting an element
or changing an element property,
Internet Explorer flags the DOM as "dirty".
When control returns to the Internet Explorer event loop,
Internet Explorer checks if the DOM is dirty, and if so,
it performs a <SPAN CLASS=term>layout pass</SPAN>,
which takes all the changes and makes them take effect.
</P>

<P>
<SPAN CLASS=term>Forcing layout</SPAN>
means forcing Internet Explorer to
perform a layout pass outside of the event loop.
</P>

<P>
The PVL needs a layout pass to take place
after the DOM has been edited
by the application so that the objects move to their final
positions, at which point
it can accurately calculate the distance the elements
have moved.
</P>

<P>
It turns out that Internet Explorer automatically forces
layout if you try to read the <VAR>offsetTop</VAR> or
<VAR>offsetLeft</VAR> properties when the layout is dirty.
Therefore, we do not need to force layout explicitly;
merely reading
<VAR>offsetTop</VAR> and
<VAR>offsetLeft</VAR> is enough to trigger layout.
</P>

<H2>
Resolving styles
</H2>

<P>
In Internet Explorer,
styles are <SPAN CLASS=term>resolved</SPAN>
when the browser recognizes the value and takes action on it.
Styles are resolved as part of the layout process,
but you can also force styles to resolve outside of layout.
</P>

<P>
Since action is taken only when styles are resolved,
if you change a property multiple times in a row
without an intervening style resolution,
then only the final value will have any effect.
</P>

<P>
The "intermediate writes are ignored" optimization
does not cause a problem with most properties,
but it affects transitions and animations
because transitions and animations capture the values
of properties at the point they are triggered,
so we have to make sure the properties have the
desired values at the point of triggering.
If we update a property, then return without resolving
styles,
then it's possible that the property will change again
before the next time styles are resolved
(say, by another call to the PVL),
resulting in the desired changes from the first animation
not taking effect.
</P>

<P>
Note that the concept of style resolution is not part of the
W3C CSS3 specification, which merely leaves to
implementation free to decide what the requirements
are for a change to a property to be counted as having
taken place before, after, or simultaneous to another
property change.
</P>

<P>
In Internet Explorer,
resolving any style on an element resolves all styles for that element,
so we can combine multiple style-resolve operations into one if
all of the modified styles apply to the same element.
</P>

<H2>Event handler gotchas</H2>

<P>
All event handlers are
registered on the <VAR>document</VAR>
rather than on the element itself,
because an element whose <VAR>disabled</VAR> property
is set to <VAR>true</VAR> does not receive events.
Instead, the event bypasses the event and immediately
bubbles to the parent.
</P>

<P>
This quirk is not documented anywhere that I can find.
</P>

<H2>Watchdog timeouts</H2>

<P>
Both transitions and animations use watchdog timeouts
to catch abandonment scenarios.
The watchdog timeout is set to the expected end of the
action, plus a little extra time to ensure that when
the action completes normally,
the completion event fires ahead of the watchdog.
</P>

<P>
Scheduling the watchdog timeout is tricky
because <CODE>setTimeout</CODE> starts the timer
immediately,
even though the animation timer doesn't start until
the next render pass.
(This is technically a violation of the CSS specification,
which says that the timer begins at the time the style
is changed.)
If we had scheduled the watchdog timer with a normal
<CODE>setTimeout</CODE>,
then a long render pass
(which can happen for complex animations)
can result in the watchdog timer firing prematurely.
</P>

<P>
Therefore, we schedule the watchdog timer as a series
of timeouts.
The first timeout is for a fixed small amount of time.
This guarantees that the first timeout will not expire
until the first render pass is complete and the animation
has started.
At that point, we can schedule the real timeout,
and this one will not fire prematurely.
</P>

<H2>Completion</H2>

<P>
Since we will sometimes cancel old actions while
setting up new ones,
we are careful to fulfill Promises asynchronously
by calling <CODE>WinJS.Utilities.Scheduler.schedule(c)</CODE> rather than
<CODE>c()</CODE>.
Otherwise, the application's completion handler might
try to schedule a third action while we are still
trying to set up the second one,
resulting in reentrancy and confusion.
</P>

<P>
The exception to this rule is in the case where the
Promise is being canceled (see below).
In that case, we complete the Promise synchronously.
This will not create reentrancy
because the cancellation was initiated by the application
in the first place.
Any cancellations performed by the Animation Engine
are done via internal mechanisms and are still completed
asynchronously.
</P>

<H2>Cancellation</H2>

<P>
When you create a Promise, you can optionally pass a
cancellation callback function which is invoked when the application
invokes the <VAR>cancel</VAR> method on the Promise.
Upon cancellation, the Promise enters the error state,
and the error handler is called.
</P>

<P>
Animations don't want to work that way.
When the application invokes <VAR>Promise.cancel</VAR>,
the animation should jump to its end state
and complete immediately with success.
</P>

<P>
We have confirmed with the base team that it is supported
and designed behavior that if a cancellation function calls
the completion callback before returning,
then the Promise will enter the fulfilled state rather
than the error state.
(This is why cancellations complete synchronously:
So that we can complete the Promise during the cancellation
callback and cause the Promise to complete with success
rather than error.)
</P>

<P>
Therefore, whenever we create a Promise, we register a
cancellation callback which cleans up the animation
(thereby jumping to the end state)
and <I>synchronously</I> invokes the cancellation function.
</P>


<H2>Optimization notes</H2>

<H3>Programmatic access to CSS styles</H3>

<P>
Styles on an element are stored in the <CODE>element.style</CODE>
object,
and calculated styles are obtained by calling
<CODE>window.getComputedStyle</CODE>.
There are three ways of accessing styles from these objects.
Here they are with their relative cost,
where indexing is normalized to have a cost of 1.
</P>

<TABLE CLASS="grid enum">
<TR CLASS="header">
    <TD>Technique</TD>
    <TD><TT>x = element.style</TT></TD>
    <TD><TT>x = getComputedStyle(element)</TT></TD>
</TR>
<TR>
    <TD><TT>x.getAttribute(propName)</TT></TD>
    <TD ALIGN=right>10.82</TD>
    <TD ALIGN=right>6.97</TD>
</TR>
<TR>
    <TD><TT>x[propName]</TT></TD>
    <TD ALIGN=right>1.00</TD>
    <TD ALIGN=right>1.00</TD>
</TR>
<TR>
    <TD><TT>x.opacity</TT></TD>
    <TD ALIGN=right>0.95</TD>
    <TD ALIGN=right>1.00</TD>
</TR>
</TABLE>

<P>
One theory is that
calling <CODE>getAttribute</CODE>
is slow because we end up making two calls into the DOM.
First, we have to ask the DOM for the function pointer
for the <CODE>getAttribute</CODE> method.
Then we have to take that raw function pointer and convert
it to a JavaScript function object.
Those two steps together are already 2&frac12; to 3&times; slower than
indexing.
Next, we have to call the JavaScript function object
with the two parameters,
which means unwrapping the object back into the raw
function pointer.
That last step takes 4&frac12; to 7&times; as long as indexing.
</P>

<P>
At any rate, it's clear that indexing is the way to access attributes
from style objects.
Switching from <VAR>getAttribute</VAR>/<VAR>setAttribute</VAR>
to indexing improved time-to-first-frame by 5%.
</P>

<P>
If you're going to be manipulating styles a lot,
you should cache the <CODE>style</CODE> object in a local
variable to avoid having to hit the DOM each time you type
<CODE>element.style</CODE>.
</P>

<H3>Parsing transitions</H3>

<P>
The translation portion of a CSS transform matrix
is in positions <CODE>e</CODE>
and <CODE>f</CODE> in the
<CODE>"matrix(a, b, c, d, e, f)"</CODE> value.
(If there is no transform, then the string
returned for <VAR>transform</VAR> is <CODE>"none"</CODE>.)
</P>

<P>
The algorithm for extracting the <CODE>e</CODE>
and <CODE>f</CODE> from the matrix string splits
the string on commas, and if six fields are produced,
it extracts fields 4 and 5 (counting from zero).
There will not be six fields if the string is <CODE>"none"</CODE>,
but in that case, the effective transform is the identity,
so there is no translation.
Note that we take advantage of the fact that <VAR>parseFloat</VAR>
ignores trailing garbage,
because field 5 will have a trailing close-parenthesis.
</P>

<P>
You might think that a more efficient algorithm would be
</P>
<PRE>
var matrix = new MSCSSMatrix(window.getComputedStyle(e).transform);
left += matrix.e;
top += matrix.f;
</PRE>

<P>
It turns out that it's three times faster
to do the parsing entirely
in native JavaScript (which can be optimized)
rather than calling into the DOM four times
(once to construct the <VAR>MSCSSMatrix</VAR>, once
to retrieve <VAR>e</VAR>,
once to retrieve <VAR>f</VAR>,
and once to destruct the matrix).
</P>

<H3>Bulk style updates</H3>

<P>
Multiple styles can be updated at once by appending to the
<CODE>cssText</CODE> property:
</P>

<PRE>
element.style.opacity = 1;
element.style.backgroundColor = "red";

// versus

element.style.cssText += "; opacity: 1; background-color: red";
</PRE>

<P>
The leading semicolon is important so that the new CSS attributes
are properly separated from the previous ones.
</P>

<P>
Although this would appear to be an improvement
since it reduces the number of round-trips to the DOM,
no measureable improvement was observed in practice
because of the cost of generating the original value of
<VAR>cssText</VAR>.
The benefit appears to be dependent on the complexity of
the existing styles on the object.
</P>

<P>
At any rate, we cannot use this technique even if it
did provide an improvement because the Internet Explorer
implementation of <VAR>cssText</VAR> does not properly
return properties whose values contain an at-sign,
semicolon, or quotation-mark.
(The at-sign is used in font names to indicate that
<A HREF="http://blogs.msdn.com/b/michkap/archive/2005/08/04/447759.aspx">
the font is vertically-oriented</A>.)
This bug in Internet Explorer is marked Won't Fix.
Since we allow animations to be triggered on arbitrary
application-provided elements,
we cannot guarantee that the application's styles avoid
the dangerous characters.
</P>

<H3>Shorthand properties</H3>

<P>
As noted in the opening discussion, shorthand properties are not
reliable for reading, but they work just fine for writing.
(Though there are problems if a name contains
an escaped reserved character, but those problems existed even
in the lifetime-property itself, so we're not introducing any new
issues here.)
</P>

<P>
Using shorthand properties for writing saves a number of round
trips into the DOM.
</P>

<H3>Disabled elements</H3>

<P>
DOM events do not propagate to disabled elements.
The AppBar control will sometimes animate disabled
elements (for example, disabled buttons will animate
into view).
</P>

<P>
The workaround is to register the listener on the document root,
which remains enabled.
However, doing this unconditionally is expensive because
it generates a lot of listener traffic which we end up
just ignoring.
Therefore, we move the registration to the document root
only if the element is disabled.
</P>

<P>
If the element is enabled at the time the action begins,
but becomes disabled during the course of the action,
then the DOM completion event will not be delivered
to the listener.
The watchdog timer catches this case and ensurse that
the Promise completes eventually.
</P>

<H3>Finishing due to interruption</H3>

<P>
It turns out that DOM events are expensive.
Therefore, we avoid them whenever possible.
</P>

<P>
We use the
<VAR>activeActions</VAR> array to keep track of all
the actions that we have scheduled which are still active.
When an actions begins, it registers with the array,
and when it completes, it unregisters.
This is a native JavaScript object and therefore can be
manipulated without going through the DOM.
</P>

<P>
As part of setting up an action,
we check if there is already an active action on
the same element and property.
If so, we finish the old action
before replacing its registration
with the new action.
</P>

<P>
By having our own table of active actions,
we don't need to listen to the
<VAR>transitionstart</VAR> event to detect
stoppage due to interruption:
We stop the action explicitly when the
interrupting action is scheduled, rather than
relying on the DOM event to notify us.
(It also is important in the case of an
interrupted Animation, because an interrupted
animation does not fire an <VAR>animationend</VAR>
event at all.)
</P>

<P>
It also allows us to stop actions on disabled elements.
As noted above, native DOM events do not propagate
to disabled elements.
</P>

<H3>The style cache</H3>

<P>
To reduces round trips to the DOM,
we retain a private cache of what we think the DOM styles are
and use that cache instead of accessing the DOM directly.
The cache is obviously write-through, because we want our
changes to take effect,
but it avoids DOM accesses on reads.
</P>

<H3>Miscellaneous failed optimizations</H3>

<P>
None of these optimizations led to measurable improvements.
</P>

<UL>
<LI>Declare all properties in the same order. This means including
    dummy values for "keyframe", "property", "from" and "to"
    in the defValue. This is one of the JS perf recommendations
    on MSDN to improve hash table lookups, but the effect was not
    measurable.

<LI>Use countdown loop instead of count-up loop to avoid retrieving
    length repeatedly.

<LI>Avoid unnecessary string concatenation. Change
    <CODE>(a ? a : "") + b</CODE>
    to
    <CODE>(a ? (b ? a + b : a) : b)</CODE>
    which avoids the concatenation if a is null or or b is <CODE>""</CODE>.

<LI>Avoid map and build array directly.

<LI>Set all properties for all elements, then resolve all styles,
    then restore all properties.
    This merely shifted costs; Internet Explorer did not
    observe any consolidation opportunities.
</UL>

<P>
These failed optimizations can be explained by the first-order
approximation that the cost of the PVL is dominated by calls into
the DOM,
and none of the above changes affected the number of calls into
the DOM.
</P>

<H1>
Transitions
</H1>

<P>
The responsibility for managing transitions is broken into
two portions.
The high-level <VAR>animations.js</VAR> file
(the <SPAN CLASS=term>animation library</SPAN>)
deals with
calculating the necessary transforms,
and the low-level
<VAR>transitionAnimation.js</VAR> file
(the <SPAN CLASS=term>animation engine</SPAN>)
deals with actually
applying them.
</P>

<P>
The first part is an interaction between the application
and the animation library.
</P>

<UL>
<LI>The application calls <VAR>create&shy;Xxx&shy;Animation</VAR>.
<LI>The animation library
    captures the current position of the element,
    then returns to the application.
<LI>The application alters the element position.
<LI>The application calls <VAR>execute</VAR>.
<LI>The animation library calculates the distance the element has moved.
    (This implicitly forces layout.)
<LI>The animation library
    applies a transform to the element which negates
    the position change performed by the application.
    (It does not need to resolve the style for reasons
    described in the section
    <SPAN CLASS=ref>Resolving the current style before animating</SPAN>.)
<LI>The animation library
    instructs the animation engine to
    animate the removal of the transform.
</UL>

<P>
The second part is handled by the low-level animation engine.
</P>

<UL>
<LI>The animation engine
    resolves styles on the element for reasons described
    in the section
    <SPAN CLASS=ref>Resolving the current style before animating</SPAN>.
<LI>The animation engine
    updates the transition-related properties on the element
    to specify that changes to the transform should be applied
    smoothly rather than instantaneously.
<LI>The animation engine removes the transform.
<LI>The animation engine resolves styles on the element,
    so that the browser observes the removal of the transform
    and begins the transition.
<LI>The animation engine restores the transition properties
    now that they are no longer needed.
<LI>When any of the following events occurs:
    <UL>
    <LI>The cleanup callback is fired by a conflicting action.
    <LI>The <VAR>transitionend</VAR> event fires.
    <LI>The timeout elapses, indicating that abandonment has occurred.
    </UL>
    we clean up and complete the Promise.
</UL>

<P>
Let's walk through the above steps with an example.
consider an object that starts out at position
<VAR>left</VAR> = 100.
</P>

<UL>
<LI>The application calls <VAR>create&shy;Xxx&shy;Animation</VAR>.
<LI>The animation library captures the current position of the element
    (100),
    then returns to the application.
<LI>The application moves the element to position
    <VAR>left</VAR> = 300.
<LI>The application calls <VAR>execute</VAR>.
<LI>The animation library observes that the element moved 200 pixels
    to the right,
    and applies a counteracting translation of
    <VAR>translateX(-200px)</VAR>.
    This causes the object's visual to appear at position 100
    (i.e., unchanged from where it was prior to the transition),
    even though its position in the layout is 300.
<LI>The animation engine adds a transition to the element
    specifying how the transform should be animated.
<LI>The animation engine removes the transform.
    Since a transition is active on the element,
    the transform animates smoothly from
    <VAR>translateX(-200px)</VAR> to
    <VAR>translateX(0)</VAR>.
    To the user, it appears as if the object moves
    smoothly from its old position to its new position.
</UL>

<P>
The remainder of this section discusses the details of the algorithm.
</P>

<H2>
Capturing the current position of the element
</H2>

<P>
The position of an element may be animating at the time
the transition is applied.
We must capture the in-flight value of the position.
</P>

<P>
The current layout position can be obtained from the
<VAR>offsetLeft</VAR>
and
<VAR>offsetTop</VAR>
properties.
</P>

<P>
The tricky part is that we also want to incorporate any
translation transform that may be active on the element.
To do this,
we use
<VAR>window.getComputedStyle(element).transform</VAR>
and extract the x- and y- coordinates from the transformation matrix.
Note that the in-flight position is relevant only when capturing
the original positions.
Final positions need to capture only the layout position,
since we are going to be changing the transform ourselves.
</P>

<H2>
Resolving the current style before animating
</H2>

<P>
It is not well-known that the browser does not respond to
a change in a CSS value until the style is resolved.
(See <SPAN CLASS=ref>Resolving styles</SPAN> above.)
As a result, many developers will write code like this
</P>

<PRE>
// incoming's initial opacity is 1.
// Set it to 0 so it will fade in.
incoming.style.opacity = 0;
WinJS.Animations.crossFade(incoming, outgoing);
</PRE>

<P>
Unless special action is taken,
this code will not actually animate from opacity 0 to 1,
because the starting opacity of 0 was never resolved
before the animation engine changed it to 1.
As a result, the browser will see that the opacity changed
from 1 to 1 and perform no animation.
</P>

<P>
To cover for this type of mistake,
the animation library will automatically resolve the initial
CSS property values so that the above code will work.
</P>

<P>
Since this workaround already is present,
we may as well take advantage of it in the animation library:
After applying the counteracting transform to each element
that moved,
we would normally resolve the style
so that the initial transform is not animated,
and so that it will be taken as the starting point of the animation.
But we can skip that step and let the animation engine do the
resolve.
</P>

<H2>
Applying the initial transform without animation
</H2>

<P>
When the animation library applies the initial counteracting
transform,
it does so without animation
because our overall design removes the transition
properties as soon as the transition begins.
Therefore, there are no leftover transition properties
that would cause the initial transform to be animated.
</P>

<P>
After setting the initial transforms, we resolve the transform
style so that the browser observes the initial value
before we start enabling transitions.
</P>

<H2>
Edge case for transitions
</H2>

<P>
Transitions are triggered by <EM>changes to</EM> element
properties.
If the target element's property has a value equal to
our desired transition target,
then no transition takes place,
and consequently, transition events do not fire.
We detect this case and convert the transition to a simple timeout.
</P>

<P>
Note that Internet Explorer returns values that may
be different from the value used to set the property.
Examples:
</P>
<UL>
<LI>Setting the <VAR>transform</VAR>
    to <TT>"translate(0.00,0)"</TT> reads back as
    <TT>"translate(0, 0)"</TT>.
    The trailing decimal places were removed,
    and a space
    was inserted after the comma.
<LI>Setting the <VAR>transform</VAR>
    to <TT>"scale(.50,.50)"</TT> reads back as
    <TT>"scale(0.5)"</TT>.
    A leading zero was inserted,
    the trailing decimal places were removed,
    and since the X-scale and Y-scale are the same,
    they were collapsed into the shorthand notation.
<LI>Setting the <VAR>opacity</VAR>
    to <TT>"0.999999999999999999999999"</TT>
    reads back as <TT>"1"</TT>.
</UL>

<P>
Internet Explorer is inconsistent as to whether
changes to equivalent values are
considered changes for the purpose of triggering
transitions.
In the above examples,
changing the <VAR>transform</VAR> to an equivalent
translation <EM>does</EM> trigger a transition,
whereas the change the equivalent <VAR>opacity</VAR>
does <EM>not</EM> trigger a transition.
</P>

<P>
To avoid surprises,
we ask Internet Explorer to munge the value
so we can see how it looks after it has been internalized
and spit back out.
To do this, we create a temporary element
(never added to the document, so it does not trigger layout)
and set the property on the temporary element,
then read it back,
and use that result as the "canonical form" for the property value.
(If for some reason, Internet Explorer is inconsistent with
its canonical forms,
the watchdog timeout will save us.)
</P>

<H2>
Interrupted transitions
</H2>

<P>
If the animating property is modified,
either by the application directly,
or because the application requested a conflicting transition,
no
<VAR>transitionend</VAR> event is fired.
From the browser's point of view,
the transition is still in progress;
it merely got redirected.
The
<VAR>transitionend</VAR> event fires
only when the new transition completes.
</P>

<P>
For the case where a conflicting action
is requested by the application,
we manually fire the cleanup callback
so that the previous transition will clean up
and get out of the way.
</P>

<P>
Note that if an application attempts to apply
a transition to an element without using the
animation engine,
the animation engine will not detect the interruption.
We do not consider this a primary scenario,
since applications should be using the animation library
for all animations.
This will instead be treated as an Abandonment scenario.
</P>

<H2>
Abandonment
</H2>

<P>
For the purpose of this document,
we shall use the term
<SPAN CLASS=term>abandonment</SPAN>
to refer to situations
in which the final
<VAR>transitionend</VAR> event does not fire,
and the interruption was not detected when
the animation engine scheduled a
conflicting action.
</P>

<H3>
Transition redirection
</H3>

<P>
As we noted above,
if a new value is set for the property undergoing transition,
the existing transition is considered to have been
<SPAN CLASS=term>redirected</SPAN>.
</P>

<H3>
Transition removal
</H3>

<P>
According to the CSS3 Transition spec, section 5:
</P>

<BLOCKQUOTE>
<P>
In the case where a transition is removed before completion,
such as if the transition-property is removed,
then the [transitionend] event will not fire.
</P>
</BLOCKQUOTE>

<P>
The example given refers to this scenario:
</P>

<UL>
<LI>Set <VAR>transition-property</VAR> to <TT>"transform"</TT>.
<LI>Modify the <VAR>transform</VAR> property, thereby triggering
    the transition.
<LI>Set <VAR>-ms-transition-property</VAR> to <TT>"opacity"</TT>.
</UL>

<P>
The act of setting
<VAR>-ms-transition-property</VAR> to <TT>"opacity"</TT>
causes the transform transition to become abandoned,
since <TT>"transform"</TT>
is no longer set.
</P>

<P>
We are careful never to remove properties from the
<VAR>-ms-transition-property</VAR>
that we did not put there ourselves.
If there are multiple transitions on the same property,
the property name appears twice in the list,
so that removal of the old transition will still leave
the property name in the list and not result in abandonment
of the new transition.
The only time this problem will occur
is the application removed the transition.
</P>

<P>
One way of detecting abandonment is to register a listener on all
attribute changes, and detect that somebody has deleted
<TT>"transform"</TT> from the
<VAR>transition-property</VAR> attribute.
We will not do this, however,
because the problem is fixed by the more
general solution below.
</P>

<H3>
Element removal
</H3>

<P>
Another case where transitions can become abandoned
is if the element is removed from the document.
There is a W3C DOM event
<VAR>DOMNodeRemovedFromDocument</VAR> which fires when
this occurs,
but Internet Explorer does not support this event.
</P>

<H3>
The watchdog timer
</H3>

<P>
We handle transition abandonment generally
by scheduling a timeout on the element which fires
slightly after the anticipated completion of the transition.
The timeout function completes the transition promise if it has
not yet completed.
</P>

<P>
The timeout is canceled as part of completion.
</P>

<P>
See <SPAN CLASS=ref>Watchdog timeouts</SPAN> for further discussion.
</P>

<H1>
Animations
</H1>

<UL>
<LI>The application calls an animation function
    in the animation library.
<LI>The animation library calls
    <VAR>executeAnimation</VAR> in the animation engine.
<LI>The animation engine creates a temporary <VAR>STYLE</VAR>
    element and inserts it into the document.
<LI>For each animation, the animation engine creates a
    keyframe in the temporary style sheet of the form
<PRE>
@-ms-keyframes uniquename {
  from { property: initialValue; }
  to { property: finalValue; }
}
</PRE>
<LI>The animation engine updates the animation properties
    on the element to include the newly-added keyframes.
    (We retain the existing animations so that it is
    possible for an element to have multiple independent
    animations.)
<LI>The animation engine resolves the animation lifetime style,
    triggering the animation.
<LI>The animation engine removes the temporary style
    sheet and returns the animation properties to their
    original values, except for the <VAR>-ms-animation-name</VAR>.
<LI>When any of the following events occurs:
    <UL>
    <LI>The <VAR>animationend</VAR> event fires.
    <LI>The timeout elapses, indicating that abandonment has occurred.
    </UL>
    we clean up and complete the Promise.
</UL>

<H2>
Interrupted animations
</H2>

<P>
Animations behave better with respect to interruptions than transitions.
If an animation is interrupted, its <VAR>animationend</VAR> event
still fires.
</P>

<H2>
Abandoned animations
</H2>

<P>
Animations can become abandoned if the keyframe is deleted
from the
<VAR>-ms-animation-name</VAR> property
by the application,
or if the element is destroyed.
In these cases case, no <VAR>animationend</VAR> event is fired.
</P>

<P>
We protect against this the same way we protected against
abandoned transitions:
By creating a watchdog timeout that fires if the
<VAR>animationend</VAR> event did not fire as expected.
When the watchdog timeout fires, we assume that the
animation was abandoned and perform our cleanup.
See <SPAN CLASS=ref>Watchdog timeouts</SPAN> for further discussion.
</P>

<H2>
Animation fill
</H2>

<P>
During the delay before the start of the animation,
and after the animation completes,
the element's properties are controlled by their actual styles
rather than the keyframe.
This behavior can be altered by the standard-proposed
<VAR>animation-fill-mode</VAR> property.
</P>

<TABLE CLASS="grid enum">
<TR CLASS="header">
    <TD>Fill mode</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>none (default)</TD>
    <TD>properties are not affected outside the animation timeline</TD>
</TR>
<TR>
    <TD>backwards</TD>
    <TD>after the animation is applied and before the animation starts,
        the properties have the value
        of the keyframe's initial value</TD>
</TR>
<TR>
    <TD>forwards</TD>
    <TD>after the animation ends and until the animation is removed,
        the properties have the value
        of the keyframe's final value</TD>
</TR>
<TR>
    <TD>both</TD>
    <TD>combine backwards and forwards</TD>
</TR>
</TABLE>

<P>
The <VAR>animation-fill-mode</VAR> is a comma-separated list of values,
each one applying respectively to the corresponding comma-separated
keyframe name.
Like the other animation properties, it is captured when
the animation begins.
</P>

<P>
This property permits us to let the animation "hold"
the initial and final values outside of the keyframe.
</P>

<P>
Note, however, that the effect of the
<VAR>animation-fill-mode</VAR> extends only
as long as the animation remains applied to the element.
This creates a problem for staggered animations,
because each individual participant in the animation will
complete at a different time,
but the promise returned by the animation library
does not fire until <EM>all</EM> participating elements
have finished animating.
Each individual participant does not know when the
other participants will complete,
so it will not know how long to delay clearing
the keyframe.
This gets particularly complicated when multiple
animations are combined,
since there is no way for a Promise to know
that it has been joined or chained to another Promise.
</P>

<P>
Solving this problem would require applications who
compose animations (via chaining or joining)
to communicate the
"final completion" back into the animation engine
so it can perform final cleanup.
This is problematic,
so we solve the problem by punting:
If the application wants the object to
retain its final property, it needs to set
that property prior to triggering the animation.
</P>

<PRE>
e.style.opacity = 0; // NEW
WinJS.UI.Animation.fadeOut(e).then(function() { e.parentNode.removeChild(e); });
</PRE>

<P>
Although cumbersome, this approach does have the following
advantages:
</P>

<UL>
<LI>It is consistent with the general principle that
    non-layout animations do not make permanent changes
    to element properties. (If you want a permanent
    change, you must make it yourself.)
<LI>It makes it possible to compose animations
    into a single storyboard.
<LI>It avoids a breaking change from the animation
    library shipped at the 2011 //build/ conference.
</UL>

<P>
<SPAN CLASS=bug>
We may want to change <VAR>fadeIn</VAR> and friends from
animations to transitions, so that the final opacity sticks
at the end rather than reverting.
This does introduce a breaking change, but perhaps the
scope of the break is not significant, since people are
likely to expect the opacity to be updated anyway.
</SPAN>
</P>

<H1>
Globally enabling and disabling the PVL
</H1>

<P>
The
<VAR>enableAnimations</VAR>
and <VAR>disableAnimations</VAR> methods
allow an application to influence whether the PVL
performs animations.
The
<VAR>isAnimationEnabled</VAR>
method allows an application to query whether the PVL
will perform an animation.
This allows an application to enable or disable its
manual animations in sync with the PVL.
</P>

<P>
The animation <VAR>enableCount</VAR> starts at zero.
</P>

<P>
Calling
<VAR>enableAnimations</VAR> increments the
<VAR>enableCount</VAR>,
and calling
<VAR>disableAnimations</VAR> decrements it.
</P>

<P>
The PVL uses this algorithm to determine whether animations are performed:
</P>

<UL>
<LI>Start with the <VAR>enableCount</VAR>.
<LI>If animations are enabled by policy, then add 1.
    Otherwise, do not add 1.
<LI>If the result is greater than zero, then animations are performed.
</UL>

<P>
This model permits the following usage patterns:
</P>

<UL>
<LI><CODE>doStuff();</CODE><BR>
    If the application never disables or enables animations, then
    animations occur based on policy.
<LI><CODE>enableAnimations(); alwaysAnimates(); disableAnimations();</CODE><BR>
    If the application explicitly enables animations,
    then animations are enabled regardless of policy.
<LI><CODE>disableAnimations(); neverAnimates(); enableAnimations();</CODE><BR>
    If the application explicitly disables animations,
    then animations are disabled regardless of policy.
</UL>

<P>
Useful helper functions would be
</P>

<PRE>
function withoutAnimation(f) {
 try {
   WinJS.UI.disableAnimations();
   return f();
 } finally {
   WinJS.UI.enableAnimations();
 }
}

function forceAnimation(f) {
 try {
   WinJS.UI.enableAnimations();
   return f();
 } finally {
   WinJS.UI.disableAnimations();
 }
}

withoutAnimation(function() { neverAnimates(); });
forceAnimation(function() { alwaysAnimates(); });
</PRE>

<H1>
Compensating for time-to-first-frame issues in Internet Explorer
</H1>

<P>
To give Internet Explorer more time to set up animations and transitions,
an artificial delay of 34ms (two frames) is added to all actions
scheduled by the animation engine.
Clients can opt out of the artificial delay by setting
<VAR>exactTiming: true</VAR> in their action
descriptor.
</P>

<P>

The 34ms delay was originally added in changelist 580919 for Windows 8 bug 900769.
Windows 8 had a library delay of 34ms (two frames).

Improvements in IE in Windows 8.1 removed the need
for this delay, and the default delay is now zero.

</P>

<P>
Components which trigger CSS animations and transitions manually
can retrieve the the animation engine delay from the
<CODE>WinJS.UI._libraryDelay</CODE> property.
This returns the delay in milliseconds.
</P>

<P>
The
<CODE>WinJS.UI._libraryDelay</CODE> is writeable,
and changes take effect for all future animations and transitions.
(Animations/transitions in progress are not affected.)
</P>

<H1>
Animation engine API
</H1>

<H2>
Dynamic action properties
</H2>

<P>
<P>
Any member of the Animation or Transition object can be set to a function
rather than a fixed value.
In that case, the function is called for each element,
and its return value is used as the corresponding value
of the Animation or Transition for that element.
Using a function allows a caller to provide
a different action for each element.
For example, this technique is used to implement stagger animations,
and to allow animating objects to move to different final positions.
</P>

<P>
If you provide a function, it is called with the following parameters:
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>i</TD>
    <TD>number</TD>
    <TD>zero-based index of the animating element's group</TD>
</TR>
<TR>
    <TD>e</TD>
    <TD>DOM element</TD>
    <TD>the element being animated</TD>
</TR>
</TABLE>

<P>
For example, if the target elements for an animation or transition are
passed as <CODE>[a, [b, c], d]</CODE>,
then the callback function will be called four times:
</P>

<UL>
<LI><CODE>f(0, a);</CODE>
<LI><CODE>f(1, b);</CODE>
<LI><CODE>f(1, c);</CODE>
<LI><CODE>f(2, d);</CODE>
</UL>

<P>
The first parameter to the callback is 1 for both <VAR>b</VAR> and <VAR>c</VAR>
since they belong to the same animating group.
</P>

<H2>
Animation object
</H2>

<P>
An Animation object describes the properties of an animation.
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string (optional)</TD>
    <TD>the predefined keyframe to use for this animation.</TD>
</TR>
<TR>
    <TD>property</TD>
    <TD>string</TD>
    <TD>the property to animate.
       <TT>"transform"</TT> and <TT>"opacity"</TT>
       are the only ones used by the PVL.</TD>
</TR>
<TR>
    <TD>delay</TD>
    <TD>number</TD>
    <TD>delay before the animation begins, in milliseconds</TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD>number</TD>
    <TD>animation duration, in milliseconds</TD>
</TR>
<TR>
    <TD>timing</TD>
    <TD>string</TD>
    <TD>CSS timing function</TD>
</TR>
<TR>
    <TD>from</TD>
    <TD>value (optional if <VAR>keyframe</VAR> is provided)</TD>
    <TD>starting value for property specified by <VAR>property</VAR></TD>
</TR>
<TR>
    <TD>to</TD>
    <TD>value (optional if <VAR>keyframe</VAR> is provided)</TD>
    <TD>ending value for property specified by <VAR>property</VAR></TD>
</TR>
<TR>
    <TD>exactTiming</TD>
    <TD>boolean (optional)</TD>
    <TD>set to non-false to disable time-to-first-frame compensation.
        See <SPAN CLASS=ref>Compensating for time-to-first-frame issues in Internet Explorer</SPAN>.
    </TD>
</TR>
</TABLE>

<P>
All members are required except where noted.
</P>

<P>
If required,
the type of the
<VAR>from</VAR> and
<VAR>to</VAR> members
must be compatible with the property specified by
the <VAR>property</VAR> member.
In other words, if
<VAR>property</VAR> is <TT>"transform"</TT>,
then <VAR>from</VAR> and
<VAR>to</VAR> must be strings which are valid transforms.
If
<VAR>property</VAR> is <TT>"opacity"</TT>,
then <VAR>from</VAR> and <VAR>to</VAR>
must be numbers between 0 to 1.
</P>

<P>
(Note that the empty string is not a valid transform.
To animate to a null transform, you must specify
an explicit null transform: <TT>"none"</TT>.)
</P>

<P>
If a keyframe is provided,
then the animation will be performed according to the
sequence described by the keyframe.
In that case,
the <VAR>from</VAR> and <VAR>to</VAR> in the
<VAR>Animation</VAR> object are ignored.
Note, however, that you must still pass a <VAR>property</VAR>
which matches the keyframe, so that action conflicts
can be detected and dealt with.
</P>

<P>
Any member of the Animation object can be set to a function
that returns the desired value.
See
<SPAN CLASS=ref>Dynamic action properties</SPAN>
for more information.
</P>

<H3>
Internals
</H3>

<P>
The animation engine creates copies of the Animation object
for capture purposes, so that changes made by the calling
application to the Animation object do not interfere with
our callbacks,
and so that we can attach private information to the copy.
(Earlier versions of the animation engine modified the
Animation object, which caused problems if the application
re-used the Animation object for multiple animations.)
</P>

<P>
After copying the Animation object
(evaluating functions as necessary for dynamically properties),
we add the following internal properties to our copy:
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string</TD>
    <TD>the auto-generated unique keyframe name</TD>
</TR>
</TABLE>

<H2>
Transition object
</H2>

<P>
A Transition object describes the properties of a transition.
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>property</TD>
    <TD>string</TD>
    <TD>the property to animate.
       <TT>"transform"</TT> and <TT>"opacity"</TT>
       are the only ones used by the PVL.</TD>
</TR>
<TR>
    <TD>delay</TD>
    <TD>number</TD>
    <TD>delay before the animation begins, in milliseconds</TD>
</TR>
<TR>
    <TD>duration</TD>
    <TD>number</TD>
    <TD>transition duration, in milliseconds</TD>
</TR>
<TR>
    <TD>timing</TD>
    <TD>string</TD>
    <TD>CSS timing function</TD>
</TR>
<TR>
    <TD>from</TD>
    <TD>value (optional)</TD>
    <TD>starting value for property specified by <VAR>property</VAR>.
    If not specified, then property begins animating from its
    current value.</TD>
</TR>
<TR>
    <TD>to</TD>
    <TD>value</TD>
    <TD>target value for property specified by <VAR>property</VAR></TD>
</TR>
<TR>
    <TD>exactTiming</TD>
    <TD>boolean (optional)</TD>
    <TD>set to non-false to disable time-to-first-frame compensation.
        See <SPAN CLASS=ref>Compensating for time-to-first-frame issues in Internet Explorer</SPAN>.
    </TD>
</TR>
<TR>
    <TD>skipStylesReset</TD>
    <TD>boolean (optional)</TD>
    <TD>set to non-false to disable setting the transition style to empty when the transition ends.
        This can improve performance of scenario where the element will be removed from the DOM when
        the transition ends.
    </TD>
</TR>
</TABLE>

<P>
All members are required except where noted.
</P>

<P>
The type of the <VAR>to</VAR> member
must be compatible with the property specified by <VAR>property</VAR>.
In other words, if
<VAR>property</VAR> is <TT>"transform"</TT>,
then <VAR>to</VAR> must be a string.
If
<VAR>property</VAR> is <TT>"opacity"</TT>,
then <VAR>to</VAR> must be a number between 0 and 1.
</P>

<P>
(Note that unlike animations, for Transitions,
you pass the empty string
<TT>""</TT> as the <VAR>to</VAR> value if the
<VAR>property</VAR> is <TT>"transform"</TT>.)
</P>

<H3>
Internals
</H3>

<P>
As with Animation objects,
the animation engine creates copies of the Transition object
for capture purposes as part of the evaluation.
Otherwise, if the application modified the
<VAR>property</VAR> member after the call to
<VAR>executeTransition</VAR> returned,
our event handlers would be looking at the wrong property.
</P>

<H1>
Animation Engine function notes
</H2>

<H2>
Action descriptor object
</H2>

<P>
An action descriptor object provides the traits of an action.
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>shorthandProp</TD>
    <TD>string</TD>
    <TD>CSS name of the shorthand property that sets all the action properties at once</TD>
</TR>
<TR>
    <TD>nameProp</TD>
    <TD>string</TD>
    <TD>CSS name of property that controls action lifetime</TD>
</TR>
<TR>
    <TD>nameField</TD>
    <TD>string</TD>
    <TD>name of member of the Action/Transition object to set
        into the lifetime property</TD>
</TR>
<TR>
    <TD>props</TD>
    <TD>array</TD>
    <TD>an array of arrays, each one describing one CSS property
        and how it should be initialized
        from the Transition or Animation object.
        The properties are listed <EM>in the order they appear in the
        shorthand property</EM>.
        <TABLE CLASS="grid members" style="margin-top: 1em">
        <TR CLASS="header">
            <TD>Index</TD>
            <TD>Type</TD>
            <TD>Description</TD>
        </TR>
        <TR>
            <TD>0</TD>
            <TD>string</TD>
            <TD>CSS name of property to update</TD>
        </TR>
        <TR>
            <TD>1</TD>
            <TD>string</TD>
            <TD>name of member of the Action/Transition object to use</TD>
        </TR>
        <TR>
            <TD>2</TD>
            <TD>string</TD>
            <TD>string to append to the corresponding member value.
                For time values, this is "ms"; for other values, this is
                the null string.</TD>
        </TR>
        </TABLE>
    </TD>
</TR>
<TR>
    <TD>isTransition</TD>
    <TD>bool</TD>
    <TD><VAR>true</VAR> if this is the descriptor for a transition.
        Transitions have a few extra quirks that animations don't,
        like having to set the lifetime property to <CODE>"none"</CODE>
        to stop all transitions.
    </TD>
</TR>
<TR>
    <TD>styleCaches</TD>
    <TD>hash</TD>
    <TD>the active style cache objects, indexed by <VAR>uniqueID</VAR></TD>
</TR>
</TABLE>

<P>
There is no good reason why the
<VAR>props</VAR> is an array of arrays rather than an array
of records.
It just ended up that way for historical reasons,
and there was no justification for changing it.
(One might retroactively justify it by claiming that integer indexing
is faster than hash indexing, but the difference is
not measureable.)
</P>

<H2>
StyleCache object
</H2>

<P>
A style cache object is a JavaScript object with the following
properties:
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>cref</TD>
    <TD>number</TD>
    <TD>reference count, the number of actions
        which are using this object.
        Each action calls <CODE>removeName</CODE> when it completes.</TD>
</TR>
<TR>
    <TD>id</TD>
    <TD>string</TD>
    <TD><VAR>uniqueID</VAR> of the element whose styles are being cached</TD>
</TR>
<TR>
    <TD>desc</TD>
    <TD>object</TD>
    <TD>the action descriptor that created the style cache object</TD>
</TR>
<TR>
    <TD>removed</TD>
    <TD>hash</TD>
    <TD>lifetime object names we have removed since the last style resolution.
        This is used to detect that we need to force a style resolution
        if the same name is added back.</TD>
</TR>
<TR>
    <TD>prevStyles</TD>
    <TD>array</TD>
    <TD>the original styles on the object, to be restored when
        all actions complete.
        This array runs parallel to <VAR>desc.props</VAR>.</TD>
</TR>
<TR>
    <TD>prevNames</TD>
    <TD>array</TD>
    <TD>the original value of the <VAR>desc.nameProp</VAR> style.</TD>
</TR>
<TR>
    <TD>names</TD>
    <TD>string</TD>
    <TD>the current cached value
        of the element's <VAR>desc.nameProp</VAR> style</TD>
</TR>
</TABLE>

<P>
Note that
<STRONG>
we do not cache a reference to the HTML element or any other DOM
objects</STRONG>.
The style cache object refers only to strings and global objects.
That way, if there is a leak (for example, due to an exception),
we only leak some JavaScript strings and objects and not HTML elements
(or worse, HTML element <EM>trees</EM>).
</P>

<P>
When the reference count drops to zero,
the original styles are restored from the <VAR>prevStyles</VAR>
and <VAR>prevNames</VAR> members.
</P>

<P>
The underlying problem is that changes to the lifetime property
are detected only at resolve time.
This causes problems for animations, because an animation
often interrupts another instance of itself.
When that happens, we want the animation to restart,
which means that we need to delete the animation from the
<VAR>animation-name</VAR> property, resolve the style
(so that the browser sees the deletion),
then add it back.
</P>

<P>
To detect the case where we need to force a resolution before
setting the new value,
we see if the animation being added is one that was recently
removed.
If so, then we force a resolution to ensure
that the deletion is seen by the browser.
</P>

<P>
The <VAR>removed</VAR> hash can be cleared if we explicitly
resolve styles.
But in the common case, the styles are resolved implicitly by the event loop,
so we do not know exactly when it has occurred.
It is not worth scheduling a
<VAR>setImmediate</VAR> to clear the hash,
because the cost of calling into the DOM to manage the callback
far exceeds the savings of this technique.
(Two DOM calls, one to cancel the old immediate and another to schedule
a new one.)
</P>

<P>
In practice, objects are not continually kept in an animating state,
because PVL animations do not support autorepeat; they are all one-shot
animations.
Eventually, objects stop animating, and then the entire style cache
object goes away.
</P>

<P>
Note that if an application starts a new animation on completion of an
old animation, we do have a brief moment where there are no active
animations, so that case is not considered a "continual animation."
To get a continual animation, the application would have to keep
interrupting the animation with a new animation and never let the
old animation end naturally.
</P>

<H3>
StyleCache constructor
</H3>

<P>
Create a new StyleCache object associated with a particular element
by capturing the element's initial styles (so they can be restored
later).
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>id</TD>
    <TD>string</TD>
    <TD><VAR>uniqueID</VAR> of the element whose styles are being cached</TD>
</TR>
<TR>
    <TD>desc</TD>
    <TD>object</TD>
    <TD>the action descriptor that created the style cache object</TD>
</TR>
<TR>
    <TD>style</TD>
    <TD>StyleCSSProperties</TD>
    <TD><VAR>style</VAR> object of the target element</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>StyleCache object</TD>
    <TD>The newly-constructed StyleCache object</TD>
</TR>
</TABLE>

<H3>
StyleCache.destroy method
</H3>

<P>
Destroys a StyleCache object and restores the original styles
to the element being tracked.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>style</TD>
    <TD>StyleCSSProperties</TD>
    <TD><VAR>style</VAR> object of the target element</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD COLSPAN=2>none</TD>
</TR>
</TABLE>

<P>
Destroying a StyleCache object entails the following steps:
</P>

<UL>
<LI>Remove it from the list of StyleCache objects.
<LI>Restore the original styles.
    <UL>
    <LI>If the original styles are all empty strings (the common case),
        then use the shorthand property to clear all of them
        in a single DOM call.
    <LI>Otherwise, restore each one individually.
    </UL>
</UL>

<H3>
StyleCache.removeName method
</H2>

<P>
Removes a reference to an action name from the associated
action property.
If other actions remain, then the name is removed from the list.
If no other actions remain, then all styles are restored to the element,
and the style cache is destroyed.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>style</TD>
    <TD>StyleCSSProperties</TD>
    <TD><VAR>style</VAR> object of the target element</TD>
</TR>
<TR>
    <TD>name</TD>
    <TD>string</TD>
    <TD>name to remove from comma-separated list</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>DOM element (optional)</TD>
    <TD>underlying element if this is the cancellation of a transition</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=2>none</TD>
</TR>
</TABLE>

<P>
Suppose the element's
<VAR>elem.style.lifetime</VAR>
property has the value
<TT>"a, b, c, d"</TT>.
Calling
<CODE>removeName(styleCache, elem.style, "b")</CODE>
would result in the property changing to
<TT>"a, c, d"</TT>.
The <TT>"b"</TT> was removed from the list.
</P>

<P>
The lifetime property is inferred from the action descriptor
associated with the style cache object.
</P>

<P>
Remember that Internet Explorer actually separates items
with a comma <EM>and space</EM>,
so we need to include the space in our parsing algorithm.
</P>

<P>
Removing a name decrements the style cache object's reference
count, since there is one fewer outstanding action.
</P>

<P>
Remember the name as one which was recently removed,
so that we will know to force a style resolution if it is added
back.
This does not need to be done for our auto-generated names,
because those are guaranteed unique and will never be seen again.
This avoids unbounded build-up of names in the case where
the application manages to keep the element animating continuously.
</P>

<P>
As a special optimization,
if the style cache object is about to be destroyed,
then there is no point deleting the name from the lifetime property
since we're going to restore the lifetime property as part of
the style restoration that occurs during destruction.
</P>

<P>
Observe that when we update the lifetime property,
we also update the <VAR>styleCache.names</VAR> so that our
cache remains valid.
</P>

<P>
The <VAR>nameValue</VAR> local variable and the
<VAR>elem</VAR> parameter are to handle a strange edge
case with canceled transitions.
For reasons known only to the W3C, the default
value for the <VAR>transition</VAR> property is <TT>"all"</TT>.
This means that setting the value to <TT>""</TT> is not the
same as disabling all transitions; in fact, it <I>enables</I>
all transitions!
</P>

<P>
Therefore, if we are trying to cancel the last transition,
we have to set the <VAR>transition</VAR> property to
the special value <TT>"none"</TT>, resolve the style
(which forces the transition to stop),
and then set it to the empty string.
</P>

<P>
This extra step is not required for normal expiration of
transitions, because there is no need to force the transition
to stop; it already stopped on its own.
</P>

<P>
The caller passes a non-null <VAR>elem</VAR> if it is calling to
cancel a transition.
We then perform the extra step if we find that we just removed
the last transition.
</P>

<P>
Note that it is possible for the last name to be removed from
the <VAR>this.names</VAR> but still have a nonzero reference count.
That happens if the last name was removed as part of canceling an
old action while we set up a new one.
In that case, we do not want to force any style resolution to
<CODE>"none"</CODE> because we're going to be doing a style resolution
in
<VAR>setTemporaryStyles</VAR> anyway.
This avoids a wasteful double-resolve.
</P>

<H2>
makeArray
</H2>

<P>
Takes an object and converts it into something that supports
indexing and has a length property.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elements</TD>
    <TD>object (optional)</TD>
    <TD>collection or single element</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>object</TD>
    <TD>an object which supports indexing and has a
        <var>length</var> property</TD>
</TR>
</TABLE>

<P>
If a single object is passed, then we turn it into a one-element array.
</P>

<P>
If <VAR>undefined</VAR> is passed, then we turn it into a zero-element array.
</P>

<H2>
getUniqueKeyframeName
</H2>

<P>
Returns a unique string to use as a keyframe name.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=3>none</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>string</TD>
    <TD>a unique string to use as a keyframe name</TD>
</TR>
</TABLE>

<P>
JavaScript integers overflow at 2<SUP>52</SUP>. Even if running a million
animations per second, overflow will not occur for over 140 years.
I like those odds.
</P>

<H2>
isUniqueKeyframeName
</H2>

<P>
Determines whether the specified name was generated by
<VAR>getUniqueKeyframeName</VAR>.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>s</TD>
    <TD>string</TD>
    <TD>the name to check</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>boolean</TD>
    <TD><VAR>true</VAR> if the string is a name generated by
        <VAR>getUniqueKeyframeName</VAR>.</TD>
</TR>
</TABLE>

<H2>
copyWithEvaluation
</H2>

<P>
Creates a callback function which creates
a shallow copy of a JavaScript object.
If any member is a function, then the function is called
to resolve it to a scalar.
This function is used to capture
Animation and Transition objects.
</P>


<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>iElem</TD>
    <TD>zero-based index of the animating element's group</TD>
    <TD>See below</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>DOM element</TD>
    <TD>the element being animated</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function</TD>
    <TD>function which creates a shallow copy with function evaluation</TD>
</TR>
</TABLE>

<P>
The return value is a function suitable for use
as a callback for <VAR>Array.map</VAR>.
The function creates a shallow copy of the object
and returns the copy.
If any member of the source object is a function,
then the function is called with the <VAR>iElem</VAR>
and <VAR>elem</VAR> parameters.
</P>

<H2>
stopExistingAction
</H2>

<P>
Stops any active animation on an element
for a particular property.
This is done by calling the
registered cleanup function, if any,
specifying that the cleanup is due to interruption.
The finish function is expected to call
<VAR>unregisterAction</VAR>
as part of its cleanup.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>id</TD>
    <TD>string</TD>
    <TD><VAR>uniqueID</VAR> of the element</TD>
</TR>
<TR>
    <TD>prop</TD>
    <TD>string</TD>
    <TD>CSS name of property whose animation is to be canceled</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD COLSPAN=2>none</TD>
</TR>
</TABLE>

<H2>
registerAction
</H2>

<P>
Registers a function to be called if an action needs
to be canceled.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>id</TD>
    <TD>string</TD>
    <TD><VAR>uniqueID</VAR> of the element</TD>
</TR>
<TR>
    <TD>prop</TD>
    <TD>string</TD>
    <TD>CSS name of property being animated</TD>
</TR>
<TR>
    <TD>finish</TD>
    <TD>function (reason)</TD>
    <TD>function to call to clean up the animation.</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=2>none</TD>
</TR>
</TABLE>

<P>
Callers are expected to have called
<VAR>stopExistingAnimation</VAR>
at some earlier point.
</P>

<P>
The <VAR>finish</VAR> function is called as follows:
<P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>reason</TD>
    <TD>integer (optional)</TD>
    <TD>reason for cleanup.
        <TABLE CLASS="grid members" style="margin-top: 1em">
        <TR CLASS="header">
            <TD>Value</TD>
            <TD>Name</TD>
            <TD>Description</TD>
        </TR>
        <TR>
            <TD>0</TD>
            <TD><VAR>reason_ended</VAR></TD>
            <TD>The action ran to completion normally.</TD>
        </TR>
        <TR>
            <TD>1</TD>
            <TD><VAR>reason_interrupted</VAR></TD>
            <TD>The action was interrupted by a conflicting action.</TD>
        </TR>
        <TR>
            <TD>2</TD>
            <TD><VAR>reason_canceled</VAR></TD>
            <TD>The action was canceled by the application.</TD>
        </TR>
        </TABLE>
        If no reason is given, then the reason is assumed to be
        <VAR>reason_ended</VAR>.
        </TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=2>none</TD>
</TR>
</TABLE>

<H2>
unregisterAction
</H2>

<P>
Unregisters the function registered by a previous call to
<VAR>registerAction</VAR>.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>id</TD>
    <TD>string</TD>
    <TD><VAR>uniqueID</VAR> of the element</TD>
</TR>
<TR>
    <TD>prop</TD>
    <TD>string</TD>
    <TD>CSS name of property whose animation or transition has completed</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=2>none</TD>
</TR>
</TABLE>

<H2>
setTemporaryStyles
</H2>

<P>
Changes the styles of an element to add new actions,
creating a style cache object if this is the first action to be applied
to the element.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>HTMLElement</TD>
    <TD>the target element</TD>
</TR>
<TR>
    <TD>style</TD>
    <TD>StyleCSSProperties</TD>
    <TD><VAR>style</VAR> object of the target element</TD>
</TR>
<TR>
    <TD>actions</TD>
    <TD>array</TD>
    <TD>array of Transition or Animation objects</TD>
</TR>
<TR>
    <TD>desc</TD>
    <TD>action descriptor</TD>
    <TD>traits of the action to be applied</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function ()</TD>
    <TD>function to call to clean up temporary changes</TD>
</TR>
</TABLE>


<P>
The function proceeds in the following steps:
</P>

<UL>
<LI>Obtain the <VAR>styleCache</VAR> object for the element,
    creating one if necessary.
    Creating a new <VAR>styleCache</VAR> captures the original
    styles so they can be restored later.
<LI>Increment the reference count of the style cache object
    by the number of actions.
    We clean up when the corresponding number of
    <CODE>removeName</CODE> calls has been made.
    Note that it is important that we do this <EM>before</EM>
    canceling the existing actions, so that the style cache object
    will not be destroyed if we happen to cancel the last action.
    This allows us to interrupt an animation without wasteful
    style resolutions.
<LI>Stop any existing action on the same property.
<LI>If we are applying a transition, or if we are starting an animation
    that was recently removed,
    then resolve styles and reset the hash of names which were removed
    since the last style resolution.
    <UL>
    <LI>Transitions need styles to be resolved in order to observe
        the pre-transition values.
    <LI>Animations need styles to be resolved if we are restarting a
        previously-removed animation, so that the browser will observe
        the removal before we add it back.
    </UL>
<LI>Build the new shorthand string from the action properties.
    This is done by joining the individual properties
    for each action (with spaces),
    and then joining all the actions (with commas).
    Prepend the existing names, if any.
<LI>Update the shorthand property to activate all the actions at once,
    and keep the write-through cache in sync.
</UL>

<P>
If we did not force the styles to be resolved,
then they will be resolved naturally
when control returns to the event loop.
<P>

<H2>
executeElementTransition
</H2>

<P>
Apply an array of transitions to a single element.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>DOM element</TD>
    <TD>target element</TD>
</TR>
<TR>
    <TD>index</TD>
    <TD>number</TD>
    <TD>zero-based index of the animating element's group</TD>
</TR>
<TR>
    <TD>transitions</TD>
    <TD>array of Transition objects</TD>
    <TD>transitions to apply to the element</TD>
</TR>
<TR>
    <TD>promises</TD>
    <TD>array of Promise objects</TD>
    <TD>any Promises created by the function are appended to this array</TD>
</TR>
<TR>
    <TD>animate</TD>
    <TD>boolean</TD>
    <TD><VAR>true</VAR> if animations should be performed</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD COLSPAN=2>none</TD>
</TR>
</TABLE>

<P>
As we saw in the introduction, the property mapping for transitions is
as follows:
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Characteristic</TD>
    <TD>Property</TD>
    <TD>Notes</TD>
</TR>
<TR>
    <TD>Lifetime</TD>
    <TD><VAR>-ms-transition-property</VAR></TD>
    <TD></TD>
</TR>
<TR>
    <TD>Initial delay</TD>
    <TD><VAR>-ms-transition-delay</VAR></TD>
    <TD>append "ms" since the value is in milliseconds</TD>
</TR>
<TR>
    <TD>Duration</TD>
    <TD><VAR>-ms-transition-duration</VAR></TD>
    <TD>append "ms" since the value is in milliseconds</TD>
</TR>
<TR>
    <TD>Curve</TD>
    <TD><VAR>-ms-transition-timing-function</VAR></TD>
    <TD></TD>
</TR>
</TABLE>

<P>
We create private copies of the Transition
objects so that we are insulated from changes made
by the application,
and so that we can evaluate any callback functions.
</P>

<P>
If the transition has an explicit <VAR>from</VAR>,
then set it.
</P>

<P>
<EM>Subtlety</EM>:
We filter the <VAR>to</VAR> through the <VAR>uniformizeStyle</VAR>
element to account for equivalent properties.
See
<SPAN CLASS=ref>Edge case for transitions</SPAN> for further discussion.
</P>

<P>
For each transition, we hook up these callback functions:
</P>

<TABLE CLASS="grid list">
<TR CLASS="header">
    <TD>Callback</TD>
    <TD>Fired by</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>finish</TD>
    <TD>setTimeout</TD>
    <TD>Unregisters all callbacks and
        completes the promise.
        This function follows the rules for <VAR>finish</VAR> functions
        as described in <VAR>registerAction</VAR>.
    </TD>
</TR>
<TR>
    <TD>onTransitionEnd</TD>
    <TD>transitionend</TD>
    <TD>If the transition being ended is
        for the property we are animating,
        then our transition ran to completion,
        and we call the <VAR>finish</VAR> callback
        to complete our promise and clean up.</TD>
</TR>
</TABLE>

<P>
Note that event handlers are registered on the <VAR>document</VAR>
if the element is disabled,
for reasons described in
<SPAN CLASS=ref>Event handler gotchas</SPAN>.
</P>

<P>
If the element is already at the final value,
then there is no transition,
and we merely schedule the cleanup function after an
appropriate timeout.
We could have detected this case earlier and avoided all of
the event handler set-up,
but we'll do it this way to reduce churn during Windows&nbsp;8 RTM.
(The case of a null transition is not expected to be common, anyway.)
</P>

<P>
If the element is not at the final value, then we
update the value of the animating property
to trigger the transition.
We let the style resolution happen when we return to the event loop.
</P>

<P>
The timeout associated with the <VAR>finish</VAR>
callback is set in two steps to ensure that the
time-to-first-frame does not count toward the timeout.
We set the watchdog timeout to the expected completion time
<EM>after</EM> the first frame has completed.
</P>

<P>
Note that the loop over the transitions must be performed
via <VAR>forEach</VAR> rather than a <VAR>for</VAR> loop,
because we need each iteration to capture a different
<VAR>transition</VAR> local variable.
</P>

<P>
If animations are disabled
(<VAR>animate</VAR> is <VAR>false</VAR>),
then all we do is set the final values of the transitions
into the element.
No promise is generated since the operation completed synchronously.
</P>

<P>
When the <VAR>finish</VAR> function is called due to
<VAR>reason_interrupted</VAR> or <VAR>reason_canceled</VAR>,
we must pass the <VAR>elem</VAR> to
<CODE>styleCache.removeName</CODE> because we may need to set
the <VAR>transition-name</VAR> to <CODE>"none"</CODE> to force
the transition to stop.
When it is called due to
<VAR>reason_canceled</VAR>,
we pass <CODE>true</CODE> to <VAR>completePromise</VAR>
for reasons explained in
<SPAN CLASS=ref>Cancellation</SPAN>.
</P>

<H2>
executeTransition
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>see <VAR>applyAction</VAR></TD>
    <TD>target elements</TD>
</TR>
<TR>
    <TD>transitions</TD>
    <TD>array of Transition objects</TD>
    <TD>transitions to apply to the elements</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>Promise</TD>
    <TD>The promise completes when all transitions complete</TD>
    </TD>
</TR>
</TABLE>

<P>
The <VAR>executeTransition</VAR> function uses the
<VAR>applyAction</VAR> function to do the heavy lifting.
</P>

<H2>
executeElementAnimation
</H2>

<P>
Apply an array of animations to a single element.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>DOM element</TD>
    <TD>target element</TD>
</TR>
<TR>
    <TD>index</TD>
    <TD>number</TD>
    <TD>zero-based index of the animating element's group</TD>
</TR>
<TR>
    <TD>anims</TD>
    <TD>array of Animation objects</TD>
    <TD>animations to apply to the element.
        Assumes that <VAR>calcAnimationProperties</VAR> has
        already been called to reinitialize each Animation object.</TD>
</TR>
<TR>
    <TD>promises</TD>
    <TD>array of Promise objects</TD>
    <TD>any Promises created by the function are appended to this array</TD>
</TR>
<TR>
    <TD>animate</TD>
    <TD>boolean</TD>
    <TD><VAR>true</VAR> if animations should be performed</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD COLSPAN=2>none</TD>
</TR>
</TABLE>

<P>
As we saw in the introduction, the property mapping for animations is
as follows:
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Characteristic</TD>
    <TD>Property</TD>
    <TD>Notes</TD>
</TR>
<TR>
    <TD>Lifetime</TD>
    <TD><VAR>-ms-animation-name</VAR></TD>
    <TD></TD>
</TR>
<TR>
    <TD>Initial delay</TD>
    <TD><VAR>-ms-animation-delay</VAR></TD>
    <TD>append "ms" since the value is in milliseconds</TD>
</TR>
<TR>
    <TD>Duration</TD>
    <TD><VAR>-ms-animation-duration</VAR></TD>
    <TD>append "ms" since the value is in milliseconds</TD>
</TR>
<TR>
    <TD>Curve</TD>
    <TD><VAR>-ms-animation-timing-function</VAR></TD>
    <TD></TD>
</TR>
<TR>
    <TD>Direction</TD>
    <TD><VAR>-ms-animation-direction</VAR></TD>
    <TD>hard-coded to <TT>"normal"</TT></TD>
</TR>
<TR>
    <TD>Iteration</TD>
    <TD><VAR>-ms-animation-iteration-count</VAR></TD>
    <TD>hard-coded to <TT>"1"</TT></TD>
</TR>
<TR>
    <TD>Persistence</TD>
    <TD><VAR>-ms-animation-fill-mode</VAR></TD>
    <TD>hard-coded to <TT>"both"</TT></TD>
</TR>
</TABLE>

<P>
We hook up the following callback functions for each animation:
</P>

<TABLE CLASS="grid list">
<TR CLASS="header">
    <TD>Callback</TD>
    <TD>Fired by</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>finish</TD>
    <TD>setTimeout</TD>
    <TD>Unregisters all callbacks and
        completes the promise.
        This function follows the rules for <VAR>finish</VAR> functions
        as described in <VAR>registerAction</VAR>.
</TR>
<TR>
    <TD>onAnimationEnd</TD>
    <TD>animationend</TD>
    <TD>If the animation being ended is for our keyframe,
        then our animation ran to completion,
        and we call the <VAR>finish</VAR> callback
        to complete our promise and clean up.</TD>
</TR>
</TABLE>

<P>
Note that event handlers are registered on the <VAR>document</VAR>
if the element is disabled,
for reasons described in
<SPAN CLASS=ref>Event handler gotchas</SPAN>.
</P>

<P>
The timeout associated with the <VAR>finish</VAR>
callback is set in two steps to ensure that the
time-to-first-frame does not count toward the timeout.
We set the watchdog timeout to the expected completion time
<EM>after</EM> the first frame has completed.
</P>

<P>
Note that the loop over the animations must be performed
via <VAR>forEach</VAR> rather than a <VAR>for</VAR> loop,
because we need each iteration to capture a different
<VAR>anim</VAR> local variable.
</P>

<P>
If animations are disabled
(<VAR>animate</VAR> is <VAR>false</VAR>),
then we do nothing, since animations have no lasting effect.
No promise is generated since the operation completed synchronously.
</P>

<P>
If an animation requires a custom keyframe, we create a temporary
<CODE>STYLE</CODE> element to hold it.
The custom style sheet is removed after the animations have triggered.
In theory, this cleanup could be done via
<VAR>setImmediate</VAR>,
but <VAR>setImmediate</VAR> it turns out is not guaranteed to run after layout.
The current implementation of Internet Explorer runs timeouts after layout,
so we schedule a timeout and remove the element on the timeout.
(If the application emptied the document in the meantime,
<VAR>parentElement</VAR> will be <VAR>null</VAR>,
in which case
trying to disconnect from the nonexistent parent will raise a null
object exception, so watch out for that.)
</P>

<P>
In the future, we should switch to removing the style sheet when
the last animation completes or is canceled.
The original code removed the style sheet aggressively because of
the documented 31-stylesheet limit in Internet Explorer.
<A HREF="http://msdn.microsoft.com/en-us/library/ie/hh920762(v=vs.85).aspx">
That limit was removed in IE10</A>.
</P>


<H2>
executeAnimation
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>see <VAR>applyAction</VAR></TD>
    <TD>target elements</TD>
</TR>
<TR>
    <TD>anims</TD>
    <TD>array of Animation objects</TD>
    <TD>animations to apply to the elements</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>Promise</TD>
    <TD>The promise completes when all animations complete</TD>
    </TD>
</TR>
</TABLE>

<P>
The <VAR>executeAnimation</VAR> function uses the
<VAR>applyAction</VAR> function to do the heavy lifting.
</P>

<H2>
animationSettings object
</H2>

<P>
This is either a
<CODE>Windows.UI.ViewManagement.UISettings</CODE> object,
or a dummy object which reports that animations are always enabled.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Property</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>animationsEnabled</TD>
    <TD>boolean</TD>
    <TD><VAR>true</VAR> is animations are enabled in the system,
        or <VAR>false</VAR> if disabled</TD>
</TR>
</TABLE>

<P>
If we can create the
<VAR>Windows.UI.ViewManagement.UISettings</VAR> object,
then we detect whether animations are enabled by
checking the
<VAR>animationsEnabled</VAR> property,
which corresponds to the
<CODE>SPI_<WBR>GET&shy;CLIENT&shy;AREA&shy;ANIMATIONS</CODE> system parameter.
</P>

<P>
If we are unable to create the object,
then we substitute a dummy object whose hard-coded
<VAR>animationsEnabled</VAR> property is <VAR>true</VAR>.
</P>

<P>
The <CODE>try...catch</CODE> around the probe for WinRT
is to protect against problems that may occur if the Web page
happens to have a global object named <VAR>Windows</VAR>.
(Perfectly legal and not entirely unreasonable.)
If that's the case, we will take an exception when we try
to invoke WinRT methods on it,
since it's not actually WinRT.
If that happens, then we just say,
"Forget it, we don't have WinRT here."
We perform early tests against
<VAR>window.Windows</VAR> and
<VAR>Windows.UI</VAR> to avoid raising exceptions
in the common case,
thereby avoiding exception noise when the application developer
goes to debug their page.
(Otherwise, they will see this exception and think,
"Maybe that's why my page isn't working.")
</P>

<H2>
applyAction
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elem</TD>
    <TD>see below</TD>
    <TD>target elements</TD>
</TR>
<TR>
    <TD>action</TD>
    <TD>array of Transition or Animation objects</TD>
    <TD>target actions</TD>
</TR>
<TR>
    <TD>execAction</TD>
    <TD>function (elem, index, actions, promises)</TD>
    <TD>callback to apply the actions to the element.
        Any Promises are appended to the <VAR>promises</VAR> array.
        </TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>Promise</TD>
    <TD>The promise completes when all actions have completed.</TD>
</TR>
</TABLE>

<P>
The <VAR>elem</VAR> parameter can be any of the following:
</P>

<UL>
<LI><VAR>undefined</VAR>, in which case nothing animates.
<LI>A single DOM element.
<LI>An array of DOM elements.
<LI>An array of arrays of DOM elements.
    (In this case, each sub-array is treated as a single unit
    for the purposes of stagger.)
<LI>An HTMLCollection or NodeList.
</UL>

<P>
To elaborate on the array of arrays:
Suppose the parameter is <TT>[a, [b, c], d]</TT>.
This represents a transition involving four elements.
</P>

<TABLE CLASS="grid">
<TR CLASS="header">
    <TD>Element</TD>
    <TD>Stagger position</TD>
</TR>
<TR>
    <TD>a</TD>
    <TD>0</TD>
</TR>
<TR>
    <TD>b</TD>
    <TD>1</TD>
</TR>
<TR>
    <TD>c</TD>
    <TD>1</TD>
</TR>
<TR>
    <TD>d</TD>
    <TD>2</TD>
</TR>
</TABLE>

<P>
In other words, elements <VAR>b</VAR> and <VAR>c</VAR>
animate together.
</P>

<P>
We use the
algorithm described in
<SPAN CLASS=ref>Globally enabling and disabling the PVL</SPAN>
to determine whether animations are enabled.
Note that we take advantage of the fact that boolean
<VAR>true</VAR> has numeric value 1,
whereas boolean <VAR>false</VAR> has numeric value 0.
</P>

<P>
After the <VAR>execAction</VAR> has been called on each animating
element,
we join together all the <VAR>Promise</VAR>s,
forming the final
<VAR>Promise</VAR> for the action.
If there are no promises to join
(all operations completed synchronously),
we return a zero-duration timeout promise
so that the promise completes asynchronously.
This preserves event-ordering behavior when
animations are disabled.
</P>

<H1>
Animation Engine events
</H1>

<H1>
Animation Library objects
</H1>

<H2>
offset object
</H2>

<P>
Application use an <VAR>offset</VAR> object to
provide animation offsets.
</P>

<TABLE CLASS="grid members">
<TR CLASS="header">
    <TD>Member</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>top</TD>
    <TD>string: CSS [LENGTH]</TD>
    <TD>the vertical displacement</TD>
</TR>
<TR>
    <TD>left</TD>
    <TD>string: CSS [LENGTH]</TD>
    <TD>the horizontal displacement</TD>
</TR>
<TR>
    <TD>rtlflip</TD>
    <TD>boolean (optional)</TD>
    <TD>if <VAR>true</VAR>,
        change direction of <VAR>left</VAR> if applied to
        an element whose <VAR>direction</VAR> is <TT>"rtl"</TT></TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string (optional)</TD>
    <TD>if set, specifies the CSS keyframe to use for the animation. This keyframe must match the <VAR>top</VAR> and <VAR>left</VAR> parameters. 
        If a keyframe is specified, <VAR>rtlflip</VAR> must not be <VAR>true</VAR>.</TD>
</TR>
</TABLE>

<P>
The <VAR>top</VAR> and <VAR>left</VAR> are CSS [LENGTH] values,
usually pixels.
For example,
<TT>"10px"</TT>.
</P>

<P>
If the <VAR>rtlflip</VAR> property is <VAR>true</VAR>,
and the offset is being applied to an element whose
CSS <VAR>direction</VAR> property resolves to <TT>"rtl"</TT>,
then the sign of the <VAR>left</VAR> property is reversed.
</P>

<H2>
OffsetArray class
</H2>

<P>
The <VAR>OffsetArray</VAR> class
captures the offsets provided by the application.
</P>

<H3>
OffsetArray constructor
</H3>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>offset</TD>
    <TD>object</TD>
    <TD>offsets (see discussion below)</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string (optional)</TD>
    <TD>keyframe name if default used (see discussion below)</TD>
</TR>
<TR>
    <TD>defOffset</TD>
    <TD>object (optional)</TD>
    <TD>default offset to use if application did not provide one.
        If provided, this object must have <VAR>top</VAR> and <VAR>left</VAR> property.</TD>
</TR>
</TABLE>

<P>
The <VAR>OffsetArray</VAR>
constructor accepts an object in the following forms:
</P>

<UL>
<LI><VAR>Array</VAR> of <VAR>offset</VAR> objects.
<LI>Single <VAR>offset</VAR> object,
    equivalent to a single-element array containing that object.
<LI><VAR>undefined</VAR>, equivalent to an empty array.
</UL>

<P>
See the <VAR>getOffset</VAR> member function for a description of how these
parameters are interpreted to determine the offset to apply to each element.
</P>

<P>
If the <VAR>offset</VAR> is empty or undefined,
then the default offset <VAR>defOffset</VAR> is used.
</P>

<P>
If the <VAR>offset</VAR> is a single offset object or an array
with one offset, we use the
<VAR>checkKeyframe</VAR> method to see whether that offset
happens to match the default offset for this animation.
If so, we will use the keyframe.
See <VAR>checkKeyframe</VAR> for further discussion.
</P>

<P>
See the <VAR>chooseKeyframe</VAR> property for a discussion of
how we choose the keyframe in the case where the application
asks for the default offsets.
</P>

<H3>
keyframe property
</H3>

<P>
The <VAR>keyframe</VAR> property specifies the predefined
CSS animation keyframe to use, if any.
</P>

<P>
If the <VAR>OffsetArray</VAR> was constructed with an explicit
application-provided offset,
then there is no predefined keyframe.
</P>

<P>
If the <VAR>OffsetArray</VAR> was constructed with a default
offset,
then the <VAR>chooseKeyframe</VAR> function is used to determine
what keyframe to return.
</P>

<P>
In all cases, the <VAR>keyframe</VAR> property is a value
suitable for passing as the <VAR>keyframe</VAR> property
of an <VAR>Animation</VAR> object.

<H3>
checkKeyframe function
</H3>

<P>
Determines whether the application-provided offsets
match the predefined keyframe offsets.
If so, then proceeds as if the predefined offsets were used.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>offset</TD>
    <TD>offset</TD>
    <TD>Application-provided offset</TD>
</TR>
<TR>
    <TD>defOffset</TD>
    <TD>offsets</TD>
    <TD>Predefined offset</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string (optional)</TD>
    <TD>keyframe name</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>string</TD>
    <TD>static keyframe to apply to all elements</TD>
</TR>
<TR>
    <TD>function</TD>
    <TD>function to calculate keyframe for each element</TD>
</TR>
<TR>
    <TD>null</TD>
    <TD>no keyframe applies to this offset</TD>
</TR>
</TABLE>

<P>
If there is no keyframe provided,
then the function returns null,
indicating that there is no optimized keyframe
for this collection of offsets.
</P>

<P>
If the application-provided offset does not match the default
offset's <VAR>top</VAR> and <VAR>left</VAR>,
then we cannot use the predefined keyframe.
Return <VAR>null</VAR>.
</P>

<P>
If the application-provided offset flips in RTL,
but we have only an LTR keyframe, then we cannot use
the predefined keyframes.
Return <VAR>null</VAR>.
(We cannot return a function that sometimes returns a keyframe
and sometimes returns <VAR>null</VAR>,
because we need to know up front whether to pass a callback
as the <VAR>from</VAR> and <VAR>to</VAR> members of the
Animation or Transition object.)
</P>

<P>
If the application-provided offset does not flip in RTL,
then we can apply the LTR keyframe statically to
all elements.
</P>

<P>
Otherwise, the application-provided offset flips in RTL
(and therefore the default offset also flips in RTL),
so we can use <VAR>keyframeCallback</VAR> as our callback function.
</P>

<P>
Here's a table of the possibilities when a keyframe is available
and the offsets match.
</P>

<TABLE CLASS="grid other">
<TR CLASS="header">
    <TD></TD>
    <TD COLSPAN=2>offset.rtlflip</TD>
</TR>
<TR CLASS="header">
    <TD></TD>
    <TD>true</TD>
    <TD>false</TD>
</TR>
<TR>
    <TD CLASS="header">defOffset.rtlflip = true</TD>
    <TD><VAR>keyframeCallback</VAR></TD>
    <TD ROWSPAN=2 VALIGN=center><VAR>keyframe</VAR></TD>
</TR>
<TR>
    <TD CLASS="header">defOffset.rtlflip = false</TD>
    <TD><VAR>null</VAR></TD>
</TR>
</TABLE>

<H3>
chooseKeyframe function
</H3>

<P>
Calculates the static keyframe name or keyframe callback
function to use for a collection of animation offsets.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>defOffset</TD>
    <TD>offset</TD>
    <TD>Default offset to apply</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string (optional)</TD>
    <TD>keyframe name</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>string</TD>
    <TD>static keyframe to apply to all elements</TD>
</TR>
<TR>
    <TD>function</TD>
    <TD>function to calculate keyframe for each element</TD>
</TR>
<TR>
    <TD>null</TD>
    <TD>no keyframe applies to this offset</TD>
</TR>
</TABLE>

<P>
If there is no keyframe provided,
then the function returns null,
indicating that there is no optimized keyframe
for this collection of offsets.
</P>

<P>
If the <VAR>defOffset</VAR> defines a keyframe which does
not need to flip in RTL,
then the static keyframe is returned.
This causes all animations to use the same keyframe.
</P>

<P>
If the <VAR>defOffset</VAR> defines a keyframe which
must flip depending on the element's direction,
then a function is returned which returns either the keyframe name
or the keyframe name with <CODE>-rtl</CODE> appended,
depending on whether the element is LTR or RTL.
</P>

<H3>
keyframeCallback
</H3>

<P>
Callback function that decides whether to use the LTR
or RTL keyframe for an element.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string</TD>
    <TD>keyframe name.
        The keyframe must be available in both LTR and RTL versions.
        </TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function</TD>
    <TD>function to calculate keyframe for each element</TD>
</TR>
</TABLE>

<P>
The callback function returns the appropriate keyframe name
based on the element's direction.
</P>

<H3>
getOffset member
</H3>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>i</TD>
    <TD>integer</TD>
    <TD>Index of object from which to obtain offset</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>object</TD>
    <TD>an <VAR>offset</VAR> object</TD>
</TR>
</TABLE>

<P>
If the <VAR>OffsetArray</VAR> was constructed with <VAR>undefined</VAR>
or an empty array,
then the <VAR>i</VAR> parameter is ignored, and
the function returns the <VAR>defOffset</VAR> passed to the constructor.
If no <VAR>defOffset</VAR> was passed to the constructor, then a
default offset of <CODE>{ top: "0px", left: "11px", rtlflip: true }</CODE>
is returned.
</P>

<P>
If the <VAR>OffsetArray</VAR> was constructed with a single object,
then the <VAR>i</VAR> parameter is ignored, and
the single object passed to the constructor is returned.
</P>

<P>
Otherwise, the <VAR>OffsetArray</VAR> was constructed with an array.
The <VAR>i</VAR>'th element of the array is returned (zero-based index).
If fewer than <CODE>i + 1</CODE> elements are present in the array,
then the last element in the array is returned.
(Effectively, the last element repeats indefinitely.)
</P>

<H1>
Animation Library function notes
</H1>

<H2>
makeArray
</H2>

<P>
Identical to <VAR>makeArray</VAR> in the animation engine.
</P>

<H2>
collectOffsetArray
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elemArray</TD>
    <TD>collection</TD>
    <TD>target elements</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>Array</TD>
    <TD>Array of <CODE>{ top: value, left: value }</CODE> objects
    describing the current positions of the elements in the collection.</TD>
</TR>
</TABLE>

<P>
The current position of the element is its current
<VAR>offsetTop</VAR> and <VAR>offsetLeft</VAR>,
combined with any active translation transform.
</P>

<P>
See
<SPAN CLASS=ref>Optimization notes: Parsing transitions</SPAN>
for a discussion of the best way to parse the transform property.
</P>

<P>
<EM>Note</EM> that the returned array is <EM>not</EM>
an array of <VAR>offset</VAR> objects.
The <VAR>top</VAR> and <VAR>left</VAR> properties
of the objects returned by <VAR>collectOffsetArray</VAR>
are simple integers (representing pixels), not CSS lengths.
</P>

<H2>
staggerDelay
</H2>

<P>
Creates the callback function for the <VAR>delay</VAR>
member of the Animation and Transition objects
used by the Animation Engine.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>initialDelay</TD>
    <TD>number</TD>
    <TD>millisecond delay for first item</TD>
</TR>
<TR>
    <TD>extraDelay</TD>
    <TD>number</TD>
    <TD>additional millisecond delay to be added for subsequent items</TD>
</TR>
<TR>
    <TD>delayCap</TD>
    <TD>number</TD>
    <TD>maximum millisecond delay</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function (i)</TD>
    <TD>Delay computation function which returns delay in milliseconds</TD>
</TR>
</TABLE>

<P>
No animations in the animation library have a delay factor,
and they all have a delay cap, so we can optimize the stagger function
for linear stagger:
</P>

<P>
stagger = min(<VAR>initialDelay</VAR> + <VAR>extraDelay</VAR> &times; <VAR>i</VAR>, <VAR>delayCap</VAR>)
</P>

<P>
The nominal delay for item 1 is <CODE>initialDelay + extraDelay * delayFactor</CODE>.
</P>

<P>
The nominal delay for item 2 is
<CODE>initialDelay + extraDelay * delayFactor + extraDelay * delayFactor * delayFactor</CODE>.
</P>

<P>
In general, the nominal delay for item <I>n</I> is
</P>
<TABLE STYLE="text-align: center">
<TR>
    <TD><CODE>nominalDelay</CODE></TD>
    <TD>=</TD>
    <TD ALIGN=left><CODE>initialDelay</CODE> &nbsp; +
        <TABLE STYLE="display: inline-table">
        <TR VALIGN=baseline>
        <TD STYLE="font-size: 300%; font-family: Cambria, serif">&#x2211;</TD>
        </TR>
        <TR>
        <TD>1 &le; <I STYLE="font-family: Cambria, serif">i</I> &le;
                   <I STYLE="font-family: Cambria, serif">n</I></TD>
        </TR>
        </TABLE>
    <CODE>extraDelay</CODE> &times;
        <CODE>delayFactor</CODE><SUP><I STYLE="font-family: Cambria, serif">i</I></SUP></TD></TR>
<TR>
    <TD></TD>
    <TD>=</TD>
    <TD ALIGN=left><CODE>initialDelay</CODE> &nbsp; +
        <CODE>extraDelay</CODE> &times; <CODE>delayFactor</CODE> &times;
        <TABLE STYLE="display: inline-table">
        <TR VALIGN=baseline>
        <TD STYLE="font-size: 300%; font-family: Cambria, serif">&#x2211;</TD>
        </TR>
        <TR>
        <TD>1 &le; <I STYLE="font-family: Cambria, serif">i</I> &le;
                   <I STYLE="font-family: Cambria, serif">n</I></TD>
        </TR>
        </TABLE>
        <CODE>extraDelay</CODE> &times;
            <CODE>delayFactor</CODE><SUP><I STYLE="font-family: Cambria, serif">i&minus;1</I></SUP></TD></TR>
<TR>
    <TD></TD>
    <TD>=</TD>
    <TD ALIGN=left><CODE>initialDelay</CODE> &nbsp; +
        <CODE>extraDelay</CODE> &times; <CODE>delayFactor</CODE> &times;
        <TABLE STYLE="display: inline-table">
        <TR VALIGN=baseline>
        <TD STYLE="font-size: 300%; font-family: Cambria, serif">&#x2211;</TD>
        </TR>
        <TR>
        <TD>0 &le; <I STYLE="font-family: Cambria, serif">i</I> &lt;
                   <I STYLE="font-family: Cambria, serif">n</I></TD>
        </TR>
        </TABLE>
        <CODE>extraDelay</CODE> &times;
            <CODE>delayFactor</CODE><SUP><I STYLE="font-family: Cambria, serif">i</I></SUP></TD></TR>
<TR>
    <TD></TD>
    <TD>=</TD>
    <TD ALIGN=left><CODE>initialDelay</CODE> &nbsp; +
        <CODE>extraDelay</CODE> &times; <CODE>delayFactor</CODE> &times;
        <TABLE STYLE="display: inline-table; vertical-align: middle">
        <TR>
        <TD>1 &minus; <CODE>delayFactor</CODE><SUP><I>n</I></SUP></TD>
        </TR>
        <TR VALIGN=baseline>
        <TD><HR></TD>
        <TR>
        <TD>1 &minus; <CODE>delayFactor</CODE></TD>
        </TR>
        </TABLE>
        </TD></TR>
</TABLE>

<P>
If a <VAR>delayCap</VAR> is specified, then the calculated delay is
<CODE>min(nominalDelay, delayCap)</CODE>.
Otherwise, the nominal delay is the calculated delay.
</P>

<H2>
makeOffsetsRelative
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elemArray</TD>
    <TD>collection</TD>
    <TD>target elements</TD>
</TR>
<TR>
    <TD>offsetArray</TD>
    <TD>array</TD>
    <TD>original positions</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD colspan=2>none</TD>
</TR>
</TABLE>

<P>
Updates <VAR>offsetArray</VAR> in place
by subtracting the corresponding current locations
of the elements in <VAR>elemArray</VAR>.
Any active transforms on the elements are ignored
for the purpose of determining the current location.
</P>

<H2>
animTranslate2DTransform
</H2>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>elemArray</TD>
    <TD>collection</TD>
    <TD>target elements</TD>
</TR>
<TR>
    <TD>offsetArray</TD>
    <TD>array</TD>
    <TD>original positions</TD>
</TR>
<TR>
    <TD>transition</TD>
    <TD>array of Transition objects</TD>
    <TD>transitions to apply to the elements</TD>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>Promise</TD>
    <TD>The promise completes when all transitions complete</TD>
</TR>
</TABLE>

<P>
A counteracting transform is applied to elements
so that their visual position corresponds to
<VAR>offsetArray</VAR>.
The transform transition is then executed via
<VAR>executeTransition</VAR>.
</P>

<H2>
translateCallback
</H2>

<P>
Creates the callback function for the <VAR>to</VAR>
amd <VAR>from</VAR>
members of the Animation and Transition objects
used by the Animation Engine.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>offsetArray</TD>
    <TD>OffsetArray</TD>
    <TD>array of offsets</TD>
</TR>
<TR>
    <TD>prefix (optional)</TD>
    <TD>string</TD>
    <TD>optional string to prefix to the translation string</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function (i, e)</TD>
    <TD>function which returns translation to apply to element number <VAR>i</VAR>, which is <VAR>e</VAR></TD>
</TR>
</TABLE>

<P>
The returned function takes a zero-based item number
and calculates the translation for that item based on the
<VAR>offsetArray</VAR>.
If the offset is marked <VAR>rtlflip</VAR> and the target
element's resolved <VAR>direction</VAR>
style is <VAR>"rtl"</VAR>,
then the value is negated.
(Note that our negation algorithm is purely textual,
and it ends up negating <TT>"0pt"</TT>
to <TT>"-0pt"</TT>.
Fortunately, <TT>"-0pt"</TT> is still a legal CSS dimension,
and it will be simplified to <TT>"0pt"</TT> by the animation engine.
</P>

<P>
If the <VAR>prefix</VAR> is present, then it is prepended
to the calculated translation.
</P>

<H2>
translateCallbackAnimate
</H2>

<P>
Creates the callback function for the <VAR>to</VAR>
amd <VAR>from</VAR>
members of the Animation object
used by the Animation Engine.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>offsetArray</TD>
    <TD>OffsetArray</TD>
    <TD>array of offsets</TD>
</TR>
<TR>
    <TD>suffix (optional)</TD>
    <TD>string</TD>
    <TD>optional string to suffix to the translation string</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function (i, e)</TD>
    <TD>function which returns translation to apply to element number <VAR>i</VAR>, which is <VAR>e</VAR></TD>
</TR>
</TABLE>

<P>
The returned function takes a zero-based item number
and calculates the translation for that item based on the
<VAR>offsetArray</VAR>.
</P>

<P>
If the <VAR>suffix</VAR> is present, then it is appended
to the calculated translation.
</P>

<P>
RTL flipping is not performed by this function.
It is assumed that <VAR>offsetArray</VAR> is based on physical
coordinates and therefore any flipping was performed during layout.
</P>

<H2>
keyframeCallbackAnimate
</H2>

<P>
Callback function that decides whether to use a keyframe
for an animation.
</P>

<TABLE CLASS="grid args">
<TR CLASS="header">
    <TD>Parameter</TD>
    <TD>Type</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>offsetArray</TD>
    <TD>OffsetArray</TD>
    <TD>array of offsets</TD>
</TR>
<TR>
    <TD>keyframe</TD>
    <TD>string</TD>
    <TD>keyframe name</TD>
</TR>
</TABLE>

<TABLE CLASS="grid returns">
<TR CLASS="header">
    <TD>Returns</TD>
    <TD>Description</TD>
</TR>
<TR>
    <TD>function</TD>
    <TD>function to calculate keyframe for each element</TD>
</TR>
</TABLE>

<P>
The callback function returns the keyframe name if the
corresponding offset is zero.
Otherwise, it returns <VAR>null</VAR> and the Animation object's
<VAR>from</VAR> and
<VAR>to</VAR> values are used.
</P>
